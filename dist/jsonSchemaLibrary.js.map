{"version":3,"file":"jsonSchemaLibrary.js","mappings":"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","sources":["webpack://jlib/webpack/universalModuleDefinition","webpack://jlib/./node_modules/@sagold/json-pointer/dist/jsonPointer.js","webpack://jlib/./node_modules/deepmerge/dist/cjs.js","webpack://jlib/./node_modules/ebnf/dist/Grammars/W3CEBNF.js","webpack://jlib/./node_modules/ebnf/dist/Parser.js","webpack://jlib/./node_modules/ebnf/dist/TokenError.js","webpack://jlib/./node_modules/fast-deep-equal/index.js","webpack://jlib/./node_modules/valid-url/index.js","webpack://jlib/webpack/bootstrap","webpack://jlib/webpack/runtime/compat get default export","webpack://jlib/webpack/runtime/define property getters","webpack://jlib/webpack/runtime/hasOwnProperty shorthand","webpack://jlib/webpack/runtime/make namespace object","webpack://jlib/webpack/runtime/node module decorator","webpack://jlib/./lib/config/strings.ts","webpack://jlib/./lib/utils/render.ts","webpack://jlib/./lib/utils/__.ts","webpack://jlib/./lib/utils/createCustomError.ts","webpack://jlib/./lib/getTypeOf.ts","webpack://jlib/./lib/types.ts","webpack://jlib/./lib/utils/filter.ts","webpack://jlib/./lib/utils/flattenArray.ts","webpack://jlib/./lib/config/settings.ts","webpack://jlib/./lib/resolveOneOf.strict.ts","webpack://jlib/./lib/utils/copy.ts","webpack://jlib/./lib/utils/merge.ts","webpack://jlib/./lib/resolveAllOf.ts","webpack://jlib/./lib/resolveOneOf.fuzzy.ts","webpack://jlib/./lib/resolveRef.strict.ts","webpack://jlib/./lib/resolveRef.merge.ts","webpack://jlib/./lib/getSchema.ts","webpack://jlib/./lib/draft/index.ts","webpack://jlib/./lib/addRemoteSchema.ts","webpack://jlib/./node_modules/@sagold/json-query/dist/module/lib/parser/jsonQueryGrammar.js","webpack://jlib/./node_modules/@sagold/json-query/dist/module/lib/parser/index.js","webpack://jlib/./node_modules/@sagold/json-query/dist/module/lib/interpreter/nodes.js","webpack://jlib/./node_modules/@sagold/json-query/dist/module/lib/interpreter/keys.js","webpack://jlib/./node_modules/@sagold/json-query/dist/module/lib/interpreter/index.js","webpack://jlib/./node_modules/@sagold/json-query/dist/module/lib/get.js","webpack://jlib/./node_modules/@sagold/json-query/dist/module/lib/split.js","webpack://jlib/./node_modules/@sagold/json-query/dist/module/lib/set.js","webpack://jlib/./node_modules/@sagold/json-query/dist/module/index.js","webpack://jlib/./lib/schema/types.ts","webpack://jlib/./lib/schema/getTypeId.ts","webpack://jlib/./lib/schema/getTypeDefs.ts","webpack://jlib/./lib/eachSchema.ts","webpack://jlib/./lib/compile/joinScope.ts","webpack://jlib/./lib/compile/splitRef.ts","webpack://jlib/./lib/compile/getRef.ts","webpack://jlib/./lib/draft06/compile/index.ts","webpack://jlib/./lib/each.ts","webpack://jlib/./lib/validation/errors.ts","webpack://jlib/./lib/validation/format.ts","webpack://jlib/./lib/getTemplate.ts","webpack://jlib/./lib/utils/isEmpty.ts","webpack://jlib/./lib/isValid.ts","webpack://jlib/./lib/utils/deepCompare.ts","webpack://jlib/./lib/utils/punycode.ucs2decode.ts","webpack://jlib/./lib/validation/keyword.ts","webpack://jlib/./lib/draft06/validation/keyword.ts","webpack://jlib/./lib/resolveAnyOf.ts","webpack://jlib/./lib/createSchemaOf.ts","webpack://jlib/./lib/getChildSchemaSelection.ts","webpack://jlib/./lib/step.ts","webpack://jlib/./lib/draft06/validation/type.ts","webpack://jlib/./lib/validate.ts","webpack://jlib/./lib/draft07/index.ts","webpack://jlib/./lib/jsoneditor/index.ts","webpack://jlib/./lib/SchemaService.ts","webpack://jlib/./lib/validateAsync.ts","webpack://jlib/./lib/compile/index.ts","webpack://jlib/./lib/compileSchema.ts","webpack://jlib/./lib/draft04/index.ts","webpack://jlib/./lib/validation/type.ts","webpack://jlib/./lib/draft06/index.ts","webpack://jlib/./index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"jlib\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"jlib\"] = factory();\n\telse\n\t\troot[\"jlib\"] = factory();\n})((typeof self !== 'undefined' ? self : this), () => {\nreturn ","!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(\"jsonPointer\",[],t):\"object\"==typeof exports?exports.jsonPointer=t():e.jsonPointer=t()}(\"undefined\"!=typeof self?self:this,(()=>(()=>{\"use strict\";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})}},t={};function n(e){return\"#\"===e||\"\"===e||Array.isArray(e)&&0===e.length||!1}e.r(t),e.d(t,{default:()=>x,get:()=>c,isRoot:()=>n,join:()=>_,remove:()=>v,removeUndefinedItems:()=>j,set:()=>y,split:()=>s});const r=/~1/g,o=/~0/g,i=/\\/+/g,l=/(^[#/]*|\\/+$)/g;function u(e){return e.replace(r,\"/\").replace(o,\"~\")}function f(e){return u(decodeURIComponent(e))}function s(e){if(null==e||\"string\"!=typeof e||n(e))return Array.isArray(e)?e:[];const t=e.indexOf(\"#\")>=0?f:u,r=(e=(e=e.replace(i,\"/\")).replace(l,\"\")).split(\"/\");for(let e=0,n=r.length;e<n;e+=1)r[e]=t(r[e]);return r}function c(e,t,r){if(null==t||null==e)return r;if(n(t))return e;const o=p(e,s(t));return void 0===o?r:o}function p(e,t){const n=t.shift();if(void 0!==e)return void 0!==n?p(e[n],t):e}const a=/^\\[.*\\]$/,d=/^\\[(.+)\\]$/;function g(e,t){return\"__proto__\"===e||\"constructor\"==e&&t.length>0&&\"prototype\"==t[0]}function y(e,t,n){if(null==t)return e;const r=s(t);if(0===r.length)return e;null==e&&(e=a.test(r[0])?[]:{});let o,i,l=e;for(;r.length>1;)o=r.shift(),i=a.test(r[0]),g(o,r)||(l=m(l,o,i));return o=r.pop(),h(l,o,n),e}function h(e,t,n){let r;const o=t.match(d);\"[]\"===t&&Array.isArray(e)?e.push(n):o?(r=o.pop(),e[r]=n):e[t]=n}function m(e,t,n){if(null!=e[t])return e[t];const r=n?[]:{};return h(e,t,r),r}function j(e){let t=0,n=0;for(;t+n<e.length;)void 0===e[t+n]&&(n+=1),e[t]=e[t+n],t+=1;return e.length=e.length-n,e}function v(e,t,n){const r=s(t),o=r.pop(),i=c(e,r);return i&&delete i[o],Array.isArray(i)&&!0!==n&&j(i),e}const b=/\\/+/g,A=/~/g,P=/\\//g;function O(e,t){if(0===e.length)return t?\"#\":\"\";for(let n=0,r=e.length;n<r;n+=1)e[n]=e[n].replace(A,\"~0\").replace(P,\"~1\"),t&&(e[n]=encodeURIComponent(e[n]));return((t?\"#/\":\"/\")+e.join(\"/\")).replace(b,\"/\")}function _(e,...t){const n=[];if(Array.isArray(e))return O(e,!0===arguments[1]);const r=arguments[arguments.length-1],o=\"boolean\"==typeof r?r:e&&\"#\"===e[0];for(let e=0,t=arguments.length;e<t;e+=1)n.push.apply(n,s(arguments[e]));const i=[];for(let e=0,t=n.length;e<t;e+=1)if(\"..\"===n[e]){if(0===i.length)return o?\"#\":\"\";i.pop()}else i.push(n[e]);return O(i,o)}const x={get:c,set:y,remove:v,join:_,split:s,splitLast:function(e){const t=s(e);if(0===t.length)return\"string\"==typeof e&&\"#\"===e[0]?[\"#\",t[0]]:[\"\",void 0];if(1===t.length)return\"#\"===e[0]?[\"#\",t[0]]:[\"\",t[0]];const n=t.pop();return[_(t,\"#\"===e[0]),n]},isRoot:n,removeUndefinedItems:j};return t})()));","'use strict';\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn target.propertyIsEnumerable(symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n","\"use strict\";\n// https://www.w3.org/TR/REC-xml/#NT-Name\n// http://www.bottlecaps.de/rr/ui\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Grammar\t::=\tProduction*\n// Production\t::=\tNCName '::=' Choice\n// NCName\t::=\t[http://www.w3.org/TR/xml-names/#NT-NCName]\n// Choice\t::=\tSequenceOrDifference ( '|' SequenceOrDifference )*\n// SequenceOrDifference\t::=\t(Item ( '-' Item | Item* ))?\n// Item\t::=\tPrimary ( '?' | '*' | '+' )?\n// Primary\t::=\tNCName | StringLiteral | CharCode | CharClass | '(' Choice ')'\n// StringLiteral\t::=\t'\"' [^\"]* '\"' | \"'\" [^']* \"'\"\n// CharCode\t::=\t'#x' [0-9a-fA-F]+\n// CharClass\t::=\t'[' '^'? ( RULE_Char | CharCode | CharRange | CharCodeRange )+ ']'\n// RULE_Char\t::=\t[http://www.w3.org/TR/xml#NT-RULE_Char]\n// CharRange\t::=\tRULE_Char '-' ( RULE_Char - ']' )\n// CharCodeRange\t::=\tCharCode '-' CharCode\n// RULE_WHITESPACE\t::=\tRULE_S | Comment\n// RULE_S\t::=\t#x9 | #xA | #xD | #x20\n// Comment\t::=\t'/*' ( [^*] | '*'+ [^*/] )* '*'* '*/'\nconst Parser_1 = require(\"../Parser\");\nvar BNF;\n(function (BNF) {\n    BNF.RULES = [\n        {\n            name: 'Grammar',\n            bnf: [['RULE_S*', '%Atomic*', 'EOF']]\n        },\n        {\n            name: '%Atomic',\n            bnf: [['Production', 'RULE_S*']],\n            fragment: true\n        },\n        {\n            name: 'Production',\n            bnf: [['NCName', 'RULE_S*', '\"::=\"', 'RULE_WHITESPACE*', 'Choice', 'RULE_WHITESPACE*', 'RULE_EOL+', 'RULE_S*']]\n        },\n        {\n            name: 'NCName',\n            bnf: [[/[a-zA-Z][a-zA-Z_0-9]*/]]\n        },\n        {\n            name: 'Choice',\n            bnf: [['SequenceOrDifference', '%_Choice_1*']],\n            fragment: true\n        },\n        {\n            name: '%_Choice_1',\n            bnf: [['RULE_WHITESPACE*', '\"|\"', 'RULE_WHITESPACE*', 'SequenceOrDifference']],\n            fragment: true\n        },\n        {\n            name: 'SequenceOrDifference',\n            bnf: [['Item', 'RULE_WHITESPACE*', '%_Item_1?']]\n        },\n        {\n            name: '%_Item_1',\n            bnf: [['Minus', 'Item'], ['Item*']],\n            fragment: true\n        },\n        {\n            name: 'Minus',\n            bnf: [['\"-\"']]\n        },\n        {\n            name: 'Item',\n            bnf: [['RULE_WHITESPACE*', '%Primary', 'PrimaryDecoration?']],\n            fragment: true\n        },\n        {\n            name: 'PrimaryDecoration',\n            bnf: [['\"?\"'], ['\"*\"'], ['\"+\"']]\n        },\n        {\n            name: 'DecorationName',\n            bnf: [['\"ebnf://\"', /[^\\x5D#]+/]]\n        },\n        {\n            name: '%Primary',\n            bnf: [['NCName'], ['StringLiteral'], ['CharCode'], ['CharClass'], ['SubItem']],\n            fragment: true\n        },\n        {\n            name: 'SubItem',\n            bnf: [['\"(\"', 'RULE_WHITESPACE*', 'Choice', 'RULE_WHITESPACE*', '\")\"']]\n        },\n        {\n            name: 'StringLiteral',\n            bnf: [[`'\"'`, /[^\"]*/, `'\"'`], [`\"'\"`, /[^']*/, `\"'\"`]],\n            pinned: 1\n        },\n        {\n            name: 'CharCode',\n            bnf: [['\"#x\"', /[0-9a-zA-Z]+/]]\n        },\n        {\n            name: 'CharClass',\n            bnf: [[\"'['\", \"'^'?\", '%RULE_CharClass_1+', '\"]\"']]\n        },\n        {\n            name: '%RULE_CharClass_1',\n            bnf: [['CharCodeRange'], ['CharRange'], ['CharCode'], ['RULE_Char']],\n            fragment: true\n        },\n        {\n            name: 'RULE_Char',\n            bnf: [[/\\x09/], [/\\x0A/], [/\\x0D/], [/[\\x20-\\x5c]/], [/[\\x5e-\\uD7FF]/], [/[\\uE000-\\uFFFD]/]]\n        },\n        {\n            name: 'CharRange',\n            bnf: [['RULE_Char', '\"-\"', 'RULE_Char']]\n        },\n        {\n            name: 'CharCodeRange',\n            bnf: [['CharCode', '\"-\"', 'CharCode']]\n        },\n        {\n            name: 'RULE_WHITESPACE',\n            bnf: [['%RULE_WHITESPACE_CHAR*'], ['Comment', 'RULE_WHITESPACE*']]\n        },\n        {\n            name: 'RULE_S',\n            bnf: [['RULE_WHITESPACE', 'RULE_S*'], ['RULE_EOL', 'RULE_S*']]\n        },\n        {\n            name: '%RULE_WHITESPACE_CHAR',\n            bnf: [[/\\x09/], [/\\x20/]],\n            fragment: true\n        },\n        {\n            name: 'Comment',\n            bnf: [['\"/*\"', '%RULE_Comment_Body*', '\"*/\"']]\n        },\n        {\n            name: '%RULE_Comment_Body',\n            bnf: [['!\"*/\"', /[^*]/]],\n            fragment: true\n        },\n        {\n            name: 'RULE_EOL',\n            bnf: [[/\\x0D/, /\\x0A/], [/\\x0A/], [/\\x0D/]]\n        },\n        {\n            name: 'Link',\n            bnf: [[\"'['\", 'Url', \"']'\"]]\n        },\n        {\n            name: 'Url',\n            bnf: [[/[^\\x5D:/?#]/, '\"://\"', /[^\\x5D#]+/, '%Url1?']]\n        },\n        {\n            name: '%Url1',\n            bnf: [['\"#\"', 'NCName']],\n            fragment: true\n        }\n    ];\n    BNF.defaultParser = new Parser_1.Parser(BNF.RULES, { debug: false });\n    const preDecorationRE = /^(!|&)/;\n    const decorationRE = /(\\?|\\+|\\*)$/;\n    const subExpressionRE = /^%/;\n    function getBNFRule(name, parser) {\n        if (typeof name == 'string') {\n            if (preDecorationRE.test(name))\n                return '';\n            let subexpression = subExpressionRE.test(name);\n            if (subexpression) {\n                let decoration = decorationRE.exec(name);\n                let decorationText = decoration ? decoration[0] + ' ' : '';\n                let lonely = isLonelyRule(name, parser);\n                if (lonely)\n                    return getBNFBody(name, parser) + decorationText;\n                return '(' + getBNFBody(name, parser) + ')' + decorationText;\n            }\n            return name;\n        }\n        else {\n            return name.source\n                .replace(/\\\\(?:x|u)([a-zA-Z0-9]+)/g, '#x$1')\n                .replace(/\\[\\\\(?:x|u)([a-zA-Z0-9]+)-\\\\(?:x|u)([a-zA-Z0-9]+)\\]/g, '[#x$1-#x$2]');\n        }\n    }\n    /// Returns true if the rule is a string literal or regular expression without a descendant tree\n    function isLonelyRule(name, parser) {\n        let rule = Parser_1.findRuleByName(name, parser);\n        return (rule &&\n            rule.bnf.length == 1 &&\n            rule.bnf[0].length == 1 &&\n            (rule.bnf[0][0] instanceof RegExp || rule.bnf[0][0][0] == '\"' || rule.bnf[0][0][0] == \"'\"));\n    }\n    function getBNFChoice(rules, parser) {\n        return rules.map(x => getBNFRule(x, parser)).join(' ');\n    }\n    function getBNFBody(name, parser) {\n        let rule = Parser_1.findRuleByName(name, parser);\n        if (rule)\n            return rule.bnf.map(x => getBNFChoice(x, parser)).join(' | ');\n        return 'RULE_NOT_FOUND {' + name + '}';\n    }\n    function emit(parser) {\n        let acumulator = [];\n        parser.grammarRules.forEach(l => {\n            if (!/^%/.test(l.name)) {\n                let recover = l.recover ? ' /* { recoverUntil=' + l.recover + ' } */' : '';\n                acumulator.push(l.name + ' ::= ' + getBNFBody(l.name, parser) + recover);\n            }\n        });\n        return acumulator.join('\\n');\n    }\n    BNF.emit = emit;\n    let subitems = 0;\n    function restar(total, resta) {\n        console.log('reberia restar ' + resta + ' a ' + total);\n        throw new Error('Difference not supported yet');\n    }\n    function convertRegex(txt) {\n        return new RegExp(txt\n            .replace(/#x([a-zA-Z0-9]{4})/g, '\\\\u$1')\n            .replace(/#x([a-zA-Z0-9]{3})/g, '\\\\u0$1')\n            .replace(/#x([a-zA-Z0-9]{2})/g, '\\\\x$1')\n            .replace(/#x([a-zA-Z0-9]{1})/g, '\\\\x0$1'));\n    }\n    function getSubItems(tmpRules, seq, parentName) {\n        let anterior = null;\n        let bnfSeq = [];\n        seq.children.forEach((x, i) => {\n            if (x.type == 'Minus') {\n                restar(anterior, x);\n            }\n            else {\n            }\n            let decoration = seq.children[i + 1];\n            decoration = (decoration && decoration.type == 'PrimaryDecoration' && decoration.text) || '';\n            let preDecoration = '';\n            switch (x.type) {\n                case 'SubItem':\n                    let name = '%' + (parentName + subitems++);\n                    createRule(tmpRules, x, name);\n                    bnfSeq.push(preDecoration + name + decoration);\n                    break;\n                case 'NCName':\n                case 'StringLiteral':\n                    bnfSeq.push(preDecoration + x.text + decoration);\n                    break;\n                case 'CharCode':\n                case 'CharClass':\n                    if (decoration || preDecoration) {\n                        let newRule = {\n                            name: '%' + (parentName + subitems++),\n                            bnf: [[convertRegex(x.text)]]\n                        };\n                        tmpRules.push(newRule);\n                        bnfSeq.push(preDecoration + newRule.name + decoration);\n                    }\n                    else {\n                        bnfSeq.push(convertRegex(x.text));\n                    }\n                    break;\n                case 'PrimaryDecoration':\n                    break;\n                default:\n                    throw new Error(' HOW SHOULD I PARSE THIS? ' + x.type + ' -> ' + JSON.stringify(x.text));\n            }\n            anterior = x;\n        });\n        return bnfSeq;\n    }\n    function createRule(tmpRules, token, name) {\n        let bnf = token.children.filter(x => x.type == 'SequenceOrDifference').map(s => getSubItems(tmpRules, s, name));\n        let rule = {\n            name,\n            bnf\n        };\n        let recover = null;\n        bnf.forEach(x => {\n            recover = recover || x['recover'];\n            delete x['recover'];\n        });\n        if (name.indexOf('%') == 0)\n            rule.fragment = true;\n        if (recover)\n            rule.recover = recover;\n        tmpRules.push(rule);\n    }\n    function getRules(source, parser = BNF.defaultParser) {\n        let ast = parser.getAST(source);\n        if (!ast)\n            throw new Error('Could not parse ' + source);\n        if (ast.errors && ast.errors.length) {\n            throw ast.errors[0];\n        }\n        let tmpRules = [];\n        ast.children.filter(x => x.type == 'Production').map((x) => {\n            let name = x.children.filter(x => x.type == 'NCName')[0].text;\n            createRule(tmpRules, x, name);\n        });\n        return tmpRules;\n    }\n    BNF.getRules = getRules;\n    function Transform(source, subParser = BNF.defaultParser) {\n        return getRules(source.join(''), subParser);\n    }\n    BNF.Transform = Transform;\n    class Parser extends Parser_1.Parser {\n        constructor(source, options) {\n            const subParser = options && options.debugRulesParser === true ? new Parser_1.Parser(BNF.RULES, { debug: true }) : BNF.defaultParser;\n            super(getRules(source, subParser), options);\n        }\n        emitSource() {\n            return emit(this);\n        }\n    }\n    BNF.Parser = Parser;\n})(BNF || (BNF = {}));\nexports.default = BNF;\n//# sourceMappingURL=W3CEBNF.js.map","\"use strict\";\n// https://www.ics.uci.edu/~pattis/ICS-33/lectures/ebnf.pdf\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Parser = exports.findRuleByName = exports.parseRuleName = exports.escapeRegExp = exports.readToken = void 0;\nconst UPPER_SNAKE_RE = /^[A-Z0-9_]+$/;\nconst decorationRE = /(\\?|\\+|\\*)$/;\nconst preDecorationRE = /^(@|&|!)/;\nconst WS_RULE = 'WS';\nconst TokenError_1 = require(\"./TokenError\");\nfunction readToken(txt, expr) {\n    let result = expr.exec(txt);\n    if (result && result.index == 0) {\n        if (result[0].length == 0 && expr.source.length > 0)\n            return null;\n        return {\n            type: null,\n            text: result[0],\n            rest: txt.substr(result[0].length),\n            start: 0,\n            end: result[0].length - 1,\n            fullText: result[0],\n            errors: [],\n            children: [],\n            parent: null\n        };\n    }\n    return null;\n}\nexports.readToken = readToken;\nfunction escapeRegExp(str) {\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n}\nexports.escapeRegExp = escapeRegExp;\nfunction fixRest(token) {\n    token.rest = '';\n    token.children && token.children.forEach(c => fixRest(c));\n}\nfunction fixPositions(token, start) {\n    token.start += start;\n    token.end += start;\n    token.children && token.children.forEach(c => fixPositions(c, token.start));\n}\nfunction agregateErrors(errors, token) {\n    if (token.errors && token.errors.length)\n        token.errors.forEach(err => errors.push(err));\n    token.children && token.children.forEach(tok => agregateErrors(errors, tok));\n}\nfunction parseRuleName(name) {\n    let postDecoration = decorationRE.exec(name);\n    let preDecoration = preDecorationRE.exec(name);\n    let postDecorationText = (postDecoration && postDecoration[0]) || '';\n    let preDecorationText = (preDecoration && preDecoration[0]) || '';\n    let out = {\n        raw: name,\n        name: name.replace(decorationRE, '').replace(preDecorationRE, ''),\n        isOptional: postDecorationText == '?' || postDecorationText == '*',\n        allowRepetition: postDecorationText == '+' || postDecorationText == '*',\n        atLeastOne: postDecorationText == '+',\n        lookupPositive: preDecorationText == '&',\n        lookupNegative: preDecorationText == '!',\n        pinned: preDecorationText == '@',\n        lookup: false,\n        isLiteral: false\n    };\n    out.isLiteral = out.name[0] == \"'\" || out.name[0] == '\"';\n    out.lookup = out.lookupNegative || out.lookupPositive;\n    return out;\n}\nexports.parseRuleName = parseRuleName;\nfunction findRuleByName(name, parser) {\n    let parsed = parseRuleName(name);\n    return parser.cachedRules[parsed.name] || null;\n}\nexports.findRuleByName = findRuleByName;\n/// Removes all the nodes starting with 'RULE_'\nfunction stripRules(token, re) {\n    if (token.children) {\n        let localRules = token.children.filter(x => x.type && re.test(x.type));\n        for (let i = 0; i < localRules.length; i++) {\n            let indexOnChildren = token.children.indexOf(localRules[i]);\n            if (indexOnChildren != -1) {\n                token.children.splice(indexOnChildren, 1);\n            }\n        }\n        token.children.forEach(c => stripRules(c, re));\n    }\n}\nconst ignoreMissingRules = ['EOF'];\nclass Parser {\n    constructor(grammarRules, options) {\n        this.grammarRules = grammarRules;\n        this.options = options;\n        this.cachedRules = {};\n        this.debug = options ? options.debug === true : false;\n        let errors = [];\n        let neededRules = [];\n        grammarRules.forEach(rule => {\n            let parsedName = parseRuleName(rule.name);\n            if (parsedName.name in this.cachedRules) {\n                errors.push('Duplicated rule ' + parsedName.name);\n                return;\n            }\n            else {\n                this.cachedRules[parsedName.name] = rule;\n            }\n            if (!rule.bnf || !rule.bnf.length) {\n                let error = 'Missing rule content, rule: ' + rule.name;\n                if (errors.indexOf(error) == -1)\n                    errors.push(error);\n            }\n            else {\n                rule.bnf.forEach(options => {\n                    if (typeof options[0] === 'string') {\n                        let parsed = parseRuleName(options[0]);\n                        if (parsed.name == rule.name) {\n                            let error = 'Left recursion is not allowed, rule: ' + rule.name;\n                            if (errors.indexOf(error) == -1)\n                                errors.push(error);\n                        }\n                    }\n                    options.forEach(option => {\n                        if (typeof option == 'string') {\n                            let name = parseRuleName(option);\n                            if (!name.isLiteral &&\n                                neededRules.indexOf(name.name) == -1 &&\n                                ignoreMissingRules.indexOf(name.name) == -1)\n                                neededRules.push(name.name);\n                        }\n                    });\n                });\n            }\n            if (WS_RULE == rule.name)\n                rule.implicitWs = false;\n            if (rule.implicitWs) {\n                if (neededRules.indexOf(WS_RULE) == -1)\n                    neededRules.push(WS_RULE);\n            }\n            if (rule.recover) {\n                if (neededRules.indexOf(rule.recover) == -1)\n                    neededRules.push(rule.recover);\n            }\n        });\n        neededRules.forEach(ruleName => {\n            if (!(ruleName in this.cachedRules)) {\n                errors.push('Missing rule ' + ruleName);\n            }\n        });\n        if (errors.length)\n            throw new Error(errors.join('\\n'));\n    }\n    getAST(txt, target) {\n        if (!target) {\n            target = this.grammarRules.filter(x => !x.fragment && x.name.indexOf('%') != 0)[0].name;\n        }\n        let result = this.parse(txt, target);\n        if (result) {\n            agregateErrors(result.errors, result);\n            fixPositions(result, 0);\n            // REMOVE ALL THE TAGS MATCHING /^%/\n            stripRules(result, /^%/);\n            if (!this.options || !this.options.keepUpperRules)\n                stripRules(result, UPPER_SNAKE_RE);\n            let rest = result.rest;\n            if (rest) {\n                new TokenError_1.TokenError('Unexpected end of input: \\n' + rest, result);\n            }\n            fixRest(result);\n            result.rest = rest;\n        }\n        return result;\n    }\n    emitSource() {\n        return 'CANNOT EMIT SOURCE FROM BASE Parser';\n    }\n    parse(txt, target, recursion = 0) {\n        let out = null;\n        let type = parseRuleName(target);\n        let expr;\n        let printable = this.debug && /*!isLiteral &*/ !UPPER_SNAKE_RE.test(type.name);\n        printable &&\n            console.log(new Array(recursion).join('│  ') + 'Trying to get ' + target + ' from ' + JSON.stringify(txt.split('\\n')[0]));\n        let realType = type.name;\n        let targetLex = findRuleByName(type.name, this);\n        if (type.name == 'EOF') {\n            if (txt.length) {\n                return null;\n            }\n            else if (txt.length == 0) {\n                return {\n                    type: 'EOF',\n                    text: '',\n                    rest: '',\n                    start: 0,\n                    end: 0,\n                    fullText: '',\n                    errors: [],\n                    children: [],\n                    parent: null\n                };\n            }\n        }\n        try {\n            if (!targetLex && type.isLiteral) {\n                // tslint:disable-next-line: no-eval\n                let src = eval(type.name);\n                if (src === '') {\n                    return {\n                        type: '%%EMPTY%%',\n                        text: '',\n                        rest: txt,\n                        start: 0,\n                        end: 0,\n                        fullText: '',\n                        errors: [],\n                        children: [],\n                        parent: null\n                    };\n                }\n                expr = new RegExp(escapeRegExp(src));\n                realType = null;\n            }\n        }\n        catch (e) {\n            if (e instanceof ReferenceError) {\n                console.error(e);\n            }\n            return null;\n        }\n        if (expr) {\n            let result = readToken(txt, expr);\n            if (result) {\n                result.type = realType;\n                return result;\n            }\n        }\n        else {\n            let options = targetLex.bnf;\n            if (options instanceof Array) {\n                options.forEach(phases => {\n                    if (out)\n                        return;\n                    let pinned = null;\n                    let tmp = {\n                        type: type.name,\n                        text: '',\n                        children: [],\n                        end: 0,\n                        errors: [],\n                        fullText: '',\n                        parent: null,\n                        start: 0,\n                        rest: txt\n                    };\n                    if (targetLex.fragment)\n                        tmp.fragment = true;\n                    let tmpTxt = txt;\n                    let position = 0;\n                    let allOptional = phases.length > 0;\n                    let foundSomething = false;\n                    for (let i = 0; i < phases.length; i++) {\n                        if (typeof phases[i] == 'string') {\n                            let localTarget = parseRuleName(phases[i]);\n                            allOptional = allOptional && localTarget.isOptional;\n                            let got;\n                            let foundAtLeastOne = false;\n                            do {\n                                got = null;\n                                if (targetLex.implicitWs) {\n                                    got = this.parse(tmpTxt, localTarget.name, recursion + 1);\n                                    if (!got) {\n                                        let WS;\n                                        do {\n                                            WS = this.parse(tmpTxt, WS_RULE, recursion + 1);\n                                            if (WS) {\n                                                tmp.text = tmp.text + WS.text;\n                                                tmp.end = tmp.text.length;\n                                                WS.parent = tmp;\n                                                tmp.children.push(WS);\n                                                tmpTxt = tmpTxt.substr(WS.text.length);\n                                                position += WS.text.length;\n                                            }\n                                            else {\n                                                break;\n                                            }\n                                        } while (WS && WS.text.length);\n                                    }\n                                }\n                                got = got || this.parse(tmpTxt, localTarget.name, recursion + 1);\n                                // rule ::= \"true\" ![a-zA-Z]\n                                // negative lookup, if it does not match, we should continue\n                                if (localTarget.lookupNegative) {\n                                    if (got)\n                                        return /* cancel this path */;\n                                    break;\n                                }\n                                if (localTarget.lookupPositive) {\n                                    if (!got)\n                                        return;\n                                }\n                                if (!got) {\n                                    if (localTarget.isOptional)\n                                        break;\n                                    if (localTarget.atLeastOne && foundAtLeastOne)\n                                        break;\n                                }\n                                if (got && targetLex.pinned == i + 1) {\n                                    pinned = got;\n                                    printable && console.log(new Array(recursion + 1).join('│  ') + '└─ ' + got.type + ' PINNED');\n                                }\n                                if (!got)\n                                    got = this.parseRecovery(targetLex, tmpTxt, recursion + 1);\n                                if (!got) {\n                                    if (pinned) {\n                                        out = tmp;\n                                        got = {\n                                            type: 'SyntaxError',\n                                            text: tmpTxt,\n                                            children: [],\n                                            end: tmpTxt.length,\n                                            errors: [],\n                                            fullText: '',\n                                            parent: null,\n                                            start: 0,\n                                            rest: ''\n                                        };\n                                        if (tmpTxt.length) {\n                                            new TokenError_1.TokenError(`Unexpected end of input. Expecting ${localTarget.name} Got: ${tmpTxt}`, got);\n                                        }\n                                        else {\n                                            new TokenError_1.TokenError(`Unexpected end of input. Missing ${localTarget.name}`, got);\n                                        }\n                                        printable &&\n                                            console.log(new Array(recursion + 1).join('│  ') + '└─ ' + got.type + ' ' + JSON.stringify(got.text));\n                                    }\n                                    else {\n                                        return;\n                                    }\n                                }\n                                foundAtLeastOne = true;\n                                foundSomething = true;\n                                if (got.type == '%%EMPTY%%') {\n                                    break;\n                                }\n                                got.start += position;\n                                got.end += position;\n                                if (!localTarget.lookupPositive && got.type) {\n                                    if (got.fragment) {\n                                        got.children &&\n                                            got.children.forEach(x => {\n                                                x.start += position;\n                                                x.end += position;\n                                                x.parent = tmp;\n                                                tmp.children.push(x);\n                                            });\n                                    }\n                                    else {\n                                        got.parent = tmp;\n                                        tmp.children.push(got);\n                                    }\n                                }\n                                if (localTarget.lookup)\n                                    got.lookup = true;\n                                printable &&\n                                    console.log(new Array(recursion + 1).join('│  ') + '└─ ' + got.type + ' ' + JSON.stringify(got.text));\n                                // Eat it from the input stream, only if it is not a lookup\n                                if (!localTarget.lookup && !got.lookup) {\n                                    tmp.text = tmp.text + got.text;\n                                    tmp.end = tmp.text.length;\n                                    tmpTxt = tmpTxt.substr(got.text.length);\n                                    position += got.text.length;\n                                }\n                                tmp.rest = tmpTxt;\n                            } while (got && localTarget.allowRepetition && tmpTxt.length && !got.lookup);\n                        } /* IS A REGEXP */\n                        else {\n                            let got = readToken(tmpTxt, phases[i]);\n                            if (!got) {\n                                return;\n                            }\n                            printable &&\n                                console.log(new Array(recursion + 1).join('│  ') + '└> ' + JSON.stringify(got.text) + phases[i].source);\n                            foundSomething = true;\n                            got.start += position;\n                            got.end += position;\n                            tmp.text = tmp.text + got.text;\n                            tmp.end = tmp.text.length;\n                            tmpTxt = tmpTxt.substr(got.text.length);\n                            position += got.text.length;\n                            tmp.rest = tmpTxt;\n                        }\n                    }\n                    if (foundSomething) {\n                        out = tmp;\n                        printable &&\n                            console.log(new Array(recursion).join('│  ') + '├<─┴< PUSHING ' + out.type + ' ' + JSON.stringify(out.text));\n                    }\n                });\n            }\n            if (out && targetLex.simplifyWhenOneChildren && out.children.length == 1) {\n                out = out.children[0];\n            }\n        }\n        if (!out) {\n            printable && console.log(target + ' NOT RESOLVED FROM ' + txt);\n        }\n        return out;\n    }\n    parseRecovery(recoverableToken, tmpTxt, recursion) {\n        if (recoverableToken.recover && tmpTxt.length) {\n            let printable = this.debug;\n            printable &&\n                console.log(new Array(recursion + 1).join('│  ') +\n                    'Trying to recover until token ' +\n                    recoverableToken.recover +\n                    ' from ' +\n                    JSON.stringify(tmpTxt.split('\\n')[0] + tmpTxt.split('\\n')[1]));\n            let tmp = {\n                type: 'SyntaxError',\n                text: '',\n                children: [],\n                end: 0,\n                errors: [],\n                fullText: '',\n                parent: null,\n                start: 0,\n                rest: ''\n            };\n            let got;\n            do {\n                got = this.parse(tmpTxt, recoverableToken.recover, recursion + 1);\n                if (got) {\n                    new TokenError_1.TokenError('Unexpected input: \"' + tmp.text + `\" Expecting: ${recoverableToken.name}`, tmp);\n                    break;\n                }\n                else {\n                    tmp.text = tmp.text + tmpTxt[0];\n                    tmp.end = tmp.text.length;\n                    tmpTxt = tmpTxt.substr(1);\n                }\n            } while (!got && tmpTxt.length > 0);\n            if (tmp.text.length > 0 && got) {\n                printable && console.log(new Array(recursion + 1).join('│  ') + 'Recovered text: ' + JSON.stringify(tmp.text));\n                return tmp;\n            }\n        }\n        return null;\n    }\n}\nexports.Parser = Parser;\nexports.default = Parser;\n//# sourceMappingURL=Parser.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TokenError = void 0;\nclass TokenError extends Error {\n    constructor(message, token) {\n        super(message);\n        this.message = message;\n        this.token = token;\n        if (token && token.errors)\n            token.errors.push(this);\n        else\n            throw this;\n    }\n    inspect() {\n        return 'SyntaxError: ' + this.message;\n    }\n}\nexports.TokenError = TokenError;\n//# sourceMappingURL=TokenError.js.map","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","(function(module) {\n    'use strict';\n\n    module.exports.is_uri = is_iri;\n    module.exports.is_http_uri = is_http_iri;\n    module.exports.is_https_uri = is_https_iri;\n    module.exports.is_web_uri = is_web_iri;\n    // Create aliases\n    module.exports.isUri = is_iri;\n    module.exports.isHttpUri = is_http_iri;\n    module.exports.isHttpsUri = is_https_iri;\n    module.exports.isWebUri = is_web_iri;\n\n\n    // private function\n    // internal URI spitter method - direct from RFC 3986\n    var splitUri = function(uri) {\n        var splitted = uri.match(/(?:([^:\\/?#]+):)?(?:\\/\\/([^\\/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?/);\n        return splitted;\n    };\n\n    function is_iri(value) {\n        if (!value) {\n            return;\n        }\n\n        // check for illegal characters\n        if (/[^a-z0-9\\:\\/\\?\\#\\[\\]\\@\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=\\.\\-\\_\\~\\%]/i.test(value)) return;\n\n        // check for hex escapes that aren't complete\n        if (/%[^0-9a-f]/i.test(value)) return;\n        if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value)) return;\n\n        var splitted = [];\n        var scheme = '';\n        var authority = '';\n        var path = '';\n        var query = '';\n        var fragment = '';\n        var out = '';\n\n        // from RFC 3986\n        splitted = splitUri(value);\n        scheme = splitted[1]; \n        authority = splitted[2];\n        path = splitted[3];\n        query = splitted[4];\n        fragment = splitted[5];\n\n        // scheme and path are required, though the path can be empty\n        if (!(scheme && scheme.length && path.length >= 0)) return;\n\n        // if authority is present, the path must be empty or begin with a /\n        if (authority && authority.length) {\n            if (!(path.length === 0 || /^\\//.test(path))) return;\n        } else {\n            // if authority is not present, the path must not start with //\n            if (/^\\/\\//.test(path)) return;\n        }\n\n        // scheme must begin with a letter, then consist of letters, digits, +, ., or -\n        if (!/^[a-z][a-z0-9\\+\\-\\.]*$/.test(scheme.toLowerCase()))  return;\n\n        // re-assemble the URL per section 5.3 in RFC 3986\n        out += scheme + ':';\n        if (authority && authority.length) {\n            out += '//' + authority;\n        }\n\n        out += path;\n\n        if (query && query.length) {\n            out += '?' + query;\n        }\n\n        if (fragment && fragment.length) {\n            out += '#' + fragment;\n        }\n\n        return out;\n    }\n\n    function is_http_iri(value, allowHttps) {\n        if (!is_iri(value)) {\n            return;\n        }\n\n        var splitted = [];\n        var scheme = '';\n        var authority = '';\n        var path = '';\n        var port = '';\n        var query = '';\n        var fragment = '';\n        var out = '';\n\n        // from RFC 3986\n        splitted = splitUri(value);\n        scheme = splitted[1]; \n        authority = splitted[2];\n        path = splitted[3];\n        query = splitted[4];\n        fragment = splitted[5];\n\n        if (!scheme)  return;\n\n        if(allowHttps) {\n            if (scheme.toLowerCase() != 'https') return;\n        } else {\n            if (scheme.toLowerCase() != 'http') return;\n        }\n\n        // fully-qualified URIs must have an authority section that is\n        // a valid host\n        if (!authority) {\n            return;\n        }\n\n        // enable port component\n        if (/:(\\d+)$/.test(authority)) {\n            port = authority.match(/:(\\d+)$/)[0];\n            authority = authority.replace(/:\\d+$/, '');\n        }\n\n        out += scheme + ':';\n        out += '//' + authority;\n        \n        if (port) {\n            out += port;\n        }\n        \n        out += path;\n        \n        if(query && query.length){\n            out += '?' + query;\n        }\n\n        if(fragment && fragment.length){\n            out += '#' + fragment;\n        }\n        \n        return out;\n    }\n\n    function is_https_iri(value) {\n        return is_http_iri(value, true);\n    }\n\n    function is_web_iri(value) {\n        return (is_http_iri(value) || is_https_iri(value));\n    }\n\n})(module);\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","/* eslint max-len: 0 */\nexport default {\n    // validation errors\n    AdditionalItemsError: \"Array at `{{pointer}}` may not have an additional item `{{key}}`\",\n    AdditionalPropertiesError: \"Additional property `{{property}}` on `{{pointer}}` does not match schema `{{schema}}`\",\n    AllOfError: \"Value `{{value}}` at `{{pointer}}` does not match schema of `{{allOf}}`\",\n    AnyOfError: \"Value `{{value}}` at `{{pointer}}` does not match any schema of `{{anyOf}}`\",\n    ConstError: \"Expected value at `{{pointer}}` to be `{{expected}}`, but value given is `{{value}}`\",\n    containsAnyError: \"The array at `{{pointer}}` must contain at least one item\",\n    ContainsArrayError: \"The property at `{{pointer}}` must not be an array\",\n    ContainsError: \"The array at `{{pointer}}` must contain an element that matches `{{schema}}`\",\n    EnumError: \"Expected given value `{{value}}` in `{{pointer}}` to be one of `{{values}}`\",\n    FormatDateError: \"Value `{{value}}` at `{{pointer}}` is not a valid date\",\n    FormatDateTimeError: \"Value `{{value}}` at `{{pointer}}` is not a valid date-time\",\n    FormatEmailError: \"Value `{{value}}` at `{{pointer}}` is not a valid email\",\n    FormatHostnameError: \"Value `{{value}}` at `{{pointer}}` is not a valid hostname\",\n    FormatIPV4Error: \"Value `{{value}}` at `{{pointer}}` is not a valid IPv4 address\",\n    FormatIPV4LeadingZeroError: \"IPv4 addresses starting with zero are invalid, since they are interpreted as octals\",\n    FormatIPV6Error: \"Value `{{value}}` at `{{pointer}}` is not a valid IPv6 address\",\n    FormatIPV6LeadingZeroError: \"IPv6 addresses starting with zero are invalid, since they are interpreted as octals\",\n    FormatJSONPointerError: \"Value `{{value}}` at `{{pointer}}` is not a valid json-pointer\",\n    FormatRegExError: \"Value `{{value}}` at `{{pointer}}` is not a valid regular expression\",\n    FormatTimeError: \"Value `{{value}}` at `{{pointer}}` is not a valid time\",\n    FormatURIError: \"Value `{{value}}` at `{{pointer}}` is not a valid uri\",\n    FormatURIReferenceError: \"Value `{{value}}` at `{{pointer}}` is not a valid uri-reference\",\n    FormatURITemplateError: \"Value `{{value}}` at `{{pointer}}` is not a valid uri-template\",\n    FormatURLError: \"Value `{{value}}` at `{{pointer}}` is not a valid url\",\n    InvalidDataError: \"No value may be specified in `{{pointer}}`\",\n    InvalidPropertyNameError: \"Invalid property name `{{property}}` at `{{pointer}}`\",\n    MaximumError: \"Value in `{{pointer}}` is `{{length}}`, but should be `{{maximum}}` at maximum\",\n    MaxItemsError: \"Too many items in `{{pointer}}`, should be `{{maximum}}` at most, but got `{{length}}`\",\n    MaxLengthError: \"Value `{{pointer}}` should have a maximum length of `{{maxLength}}`, but got `{{length}}`.\",\n    MaxPropertiesError: \"Too many properties in `{{pointer}}`, should be `{{maximum}}` at most, but got `{{length}}`\",\n    MinimumError: \"Value in `{{pointer}}` is `{{length}}`, but should be `{{minimum}}` at minimum\",\n    MinItemsError: \"Too few items in `{{pointer}}`, should be at least `{{minimum}}`, but got `{{length}}`\",\n    MinItemsOneError: \"At least one item is required in `{{pointer}}`\",\n    MinLengthError: \"Value `{{pointer}}` should have a minimum length of `{{minLength}}`, but got `{{length}}`.\",\n    MinLengthOneError: \"A value is required in `{{pointer}}`\",\n    MinPropertiesError: \"Too few properties in `{{pointer}}`, should be at least `{{minimum}}`, but got `{{length}}`\",\n    MissingDependencyError: \"The required propery '{{missingProperty}}' in `{{pointer}}` is missing\",\n    MissingOneOfPropertyError: \"Value at `{{pointer}}` property: `{{property}}`\",\n    MultipleOfError: \"Expected `{{value}}` in `{{pointer}}` to be multiple of `{{multipleOf}}`\",\n    MultipleOneOfError: \"Value `{{value}}` should not match multiple schemas in oneOf `{{matches}}`\",\n    NoAdditionalPropertiesError: \"Additional property `{{property}}` in `{{pointer}}` is not allowed\",\n    NotError: \"Value `{{value}}` at pointer should not match schema `{{not}}`\",\n    OneOfError: \"Value `{{value}}` in `{{pointer}}` does not match any given oneof schema\",\n    OneOfPropertyError: \"Failed finding a matching oneOfProperty schema in `{{pointer}}` where `{{property}}` matches `{{value}}`\",\n    PatternError: \"Value in `{{pointer}}` should match `{{description}}`, but received `{{received}}`\",\n    PatternPropertiesError: \"Property `{{key}}` does not match any patterns in `{{pointer}}`. Valid patterns are: {{patterns}}\",\n    RequiredPropertyError: \"The required property `{{key}}` is missing at `{{pointer}}`\",\n    TypeError: \"Expected `{{value}}` ({{received}}) in `{{pointer}}` to be of type `{{expected}}`\",\n    UndefinedValueError: \"Value must not be undefined in `{{pointer}}`\",\n    UniqueItemsError: \"Expected unique items in {{pointer}}: duplicate value `{{value}}` found at {{itemPointer}} and {{duplicatePointer}}\",\n    UnknownPropertyError: \"Could not find a valid schema for property `{{pointer}}` within object\",\n    ValueNotEmptyError: \"A value for `{{property}}` is required at `{{pointer}}`\"\n} as Record<string, string>;\n\n","/**\n * Renders data into a string by {{variables}}.\n * Given a template string, removes all {{property}} substrings and replaces them with the property in the given data\n *\n * @param template - template string containing variables in handelbars/mustache style\n * @param data - flat object containing properties matching variables\n * @return rendered string\n */\nexport default function render(template: string, data: { [p: string]: any } = {}): string {\n    return template.replace(/\\{\\{\\w+\\}\\}/g, match => data[match.replace(/[{}]/g, \"\")]);\n}\n","import strings from \"../config/strings\";\nimport render from \"./render\";\n\n\n/**\n * Renders the given string as defined in __@see config/strings.js__\n * @param keyword\n * @param data - template data\n * @param fallback - fallback template\n * @return resulting string\n */\nexport default function __(keyword: string, data: any, fallback: string = keyword): string {\n    const template = strings[keyword] || fallback;\n    return render(template, data);\n}\n","import __ from \"./__\";\nimport { JSONError, JSONPointer } from \"../types\";\n\nexport type ErrorData = { pointer: JSONPointer } & Record<string, unknown>;\nexport type CreateError = (data: ErrorData) => JSONError;\n\nfunction dashCase(text: string): string {\n    return text.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\n\nexport function createError(name: string, data: ErrorData): JSONError {\n    return {\n        type: \"error\",\n        name,\n        code: dashCase(name),\n        message: __(name, data),\n        data\n    };\n}\n\n/**\n * Creates a custom Error-Constructor which instances may be identified by `customError instanceof Error`. Its messages\n * are defined by strings-object @see config/strings.ts\n *\n * @param name - id of error (camelcased)\n * @return error constructor function\n */\nexport function createCustomError(name: string): CreateError {\n    return createError.bind(null, name);\n}\n","const toString = Object.prototype.toString;\n\nexport type JSType =\n    | \"array\"\n    | \"bigint\"\n    | \"boolean\"\n    | \"function\"\n    | \"null\"\n    | \"number\"\n    | \"object\"\n    | \"string\"\n    | \"symbol\"\n    | \"undefined\";\n\nexport default function getTypeOf(value: unknown): JSType {\n    const type = toString\n        .call(value)\n        .match(/\\s([^\\]]+)\\]/)\n        .pop()\n        .toLowerCase();\n    if (type === \"file\") {\n        return \"object\";\n    }\n    return type;\n}\n","import { Draft as Core } from \"./draft\";\n\nexport type JSONSchema = { [p: string]: any };\n\nexport type JSONPointer = string;\n\nexport type JSONError = {\n    type: \"error\";\n    name: string;\n    code: string;\n    message: string;\n    data?: { [p: string]: any };\n    [p: string]: any;\n};\n\n/**\n * ts type guard for json error\n * @returns true if passed type is a JSONError\n */\nexport function isJSONError(error: any): error is JSONError {\n    return error?.type === \"error\";\n}\n\nexport interface JSONValidator {\n    (core: Core, schema: JSONSchema, value: unknown, pointer: JSONPointer):\n        | void\n        | undefined\n        | JSONError\n        | JSONError[]\n        | JSONError[][];\n}\n\nexport interface JSONTypeValidator {\n    (core: Core, schema: JSONSchema, value: unknown, pointer: JSONPointer): Array<\n        void | undefined | JSONError | JSONError[] | JSONError[][]\n    >;\n}\n","import { isJSONError, JSONError } from \"../types\";\n\nexport function isPromise(obj: unknown): obj is Promise<unknown> {\n    return obj instanceof Promise;\n}\n\nexport function errorOrPromise(error: unknown): error is JSONError | Promise<unknown> {\n    return isJSONError(error) || isPromise(error);\n}\n\nexport function errorsOnly(error: unknown): error is JSONError {\n    return isJSONError(error);\n}\n","export default function flattenArray<T = unknown>(list: unknown[], result: T[] = []): T[] {\n    for (let i = 0; i < list.length; i += 1) {\n        const item = list[i];\n        if (Array.isArray(item)) {\n            flattenArray(item, result);\n        } else {\n            result.push(item as T);\n        }\n    }\n    return result;\n}\n","export default {\n    DECLARATOR_ONEOF: \"oneOfProperty\",\n    GET_TEMPLATE_RECURSION_LIMIT: 1,\n    floatingPointPrecision: 10000,\n    propertyBlacklist: [\"_id\"]\n};\n","import { errorOrPromise } from \"./utils/filter\";\nimport flattenArray from \"./utils/flattenArray\";\nimport settings from \"./config/settings\";\nimport { JSONSchema, JSONPointer, JSONError, isJSONError } from \"./types\";\nimport { Draft as Core } from \"./draft\";\n\nconst { DECLARATOR_ONEOF } = settings;\n\n/**\n * Selects and returns a oneOf schema for the given data\n *\n * @param core - validator\n * @param data\n * @param schema - current json schema containing property oneOf\n * @param pointer - json pointer to data\n * @return oneOf schema or an error\n */\nexport default function resolveOneOf(\n    core: Core,\n    data: any,\n    schema: JSONSchema = core.rootSchema,\n    pointer: JSONPointer = \"#\"\n): JSONSchema | JSONError {\n    // !keyword: oneOfProperty\n    // an additional <DECLARATOR_ONEOF> (default `oneOfProperty`) on the schema will exactly determine the\n    // oneOf value (if set in data)\n\n    // @fixme\n    // abort if no data is given an DECLARATOR_ONEOF is set (used by getChildSchemaSelection)\n    // this case (data != null) should not be necessary\n    if (data != null && schema[DECLARATOR_ONEOF]) {\n        const errors = [];\n        const oneOfProperty = schema[DECLARATOR_ONEOF];\n        const oneOfValue = data[schema[DECLARATOR_ONEOF]];\n\n        if (oneOfValue === undefined) {\n            return core.errors.missingOneOfPropertyError({ property: oneOfProperty, pointer });\n        }\n\n        for (let i = 0; i < schema.oneOf.length; i += 1) {\n            const one = core.resolveRef(schema.oneOf[i]);\n            const oneOfPropertySchema = core.step(oneOfProperty, one, data, pointer);\n\n            if (isJSONError(oneOfPropertySchema)) {\n                return oneOfPropertySchema;\n            }\n\n            let result = flattenArray(core.validate(oneOfValue, oneOfPropertySchema, pointer));\n            result = result.filter(errorOrPromise);\n\n            if (result.length > 0) {\n                errors.push(...result);\n            } else {\n                return one; // return resolved schema\n            }\n        }\n\n        return core.errors.oneOfPropertyError({\n            property: oneOfProperty,\n            value: oneOfValue,\n            pointer,\n            errors\n        });\n    }\n\n    const matches = [];\n    const errors = [];\n    for (let i = 0; i < schema.oneOf.length; i += 1) {\n        const one = core.resolveRef(schema.oneOf[i]);\n\n        let result = flattenArray(core.validate(data, one, pointer));\n        result = result.filter(errorOrPromise);\n\n        if (result.length > 0) {\n            errors.push(...result);\n        } else {\n            matches.push(one);\n        }\n    }\n\n    if (matches.length === 1) {\n        return matches[0];\n    }\n    if (matches.length > 1) {\n        return core.errors.multipleOneOfError({\n            value: data,\n            pointer,\n            matches\n        });\n    }\n\n    return core.errors.oneOfError({\n        value: JSON.stringify(data),\n        pointer,\n        oneOf: schema.oneOf,\n        errors\n    });\n}\n","export default <T>(value: T): T => JSON.parse(JSON.stringify(value));\n","import deepmerge from \"deepmerge\";\n\nconst overwriteMerge = (destinationArray: unknown[], sourceArray: unknown[]) => sourceArray;\n\n/**\n * returns a new json-schema, where properties are combined and arrays are replaced\n */\nexport default <T>(a: Partial<T>, b: Partial<T>): T =>\n    deepmerge(a, b, { arrayMerge: overwriteMerge });\n\n// var d = c.filter((item, pos) => c.indexOf(item) === pos)\nconst mergeUniqueItems = (destinationArray: unknown[], sourceArray: unknown[]) => {\n    const all = destinationArray.concat(sourceArray);\n    return all.filter((item, pos) => all.indexOf(item) === pos);\n};\n\n/**\n * returns a new json-schema, where properties are combined and arrays are replaced\n */\nexport const mergeArraysUnique = <T>(a: Partial<T>, b: Partial<T>): T =>\n    deepmerge(a, b, { arrayMerge: mergeUniqueItems });\n","/**\n * resolveAllOf is tricky:\n *\n * resolve all merges all schemas altough each schema in the list must be used\n * for validation. But to use this as a template schema to create data and a\n * resolved schema, structural data must be merged. Currently, it is merged in\n * all case, but separately validated and resolved. This will break at some\n * point, requiring us to be more specific on our current intent (validation\n * vs get (resolved) schema)\n */\nimport copy from \"./utils/copy\";\nimport { JSONSchema, JSONPointer, JSONError } from \"./types\";\nimport { Draft } from \"./draft\";\nimport { mergeArraysUnique } from \"./utils/merge\";\n\n/**\n * resolves schema\n * when complete this will have much duplication to step.object etc\n */\nfunction resolveSchema(draft: Draft, schemaToResolve: JSONSchema, data: unknown): JSONSchema {\n    const schema = { ...(draft.resolveRef(schemaToResolve) ?? {}) };\n\n    // @draft >= 07\n    if (schema.if && (schema.then || schema.else)) {\n        const isValid = draft.isValid(data, schema.if);\n        if (isValid && schema.then) {\n            return resolveSchema(draft, schema.then, data);\n        }\n        if (!isValid && schema.else) {\n            return resolveSchema(draft, schema.else, data);\n        }\n\n        delete schema.if;\n        delete schema.then;\n        delete schema.else;\n    }\n\n    return schema;\n}\n\nexport default function resolveAllOf(\n    draft: Draft,\n    data: any,\n    schema: JSONSchema = draft.rootSchema,\n    pointer: JSONPointer = \"#\"\n): JSONSchema | JSONError {\n    let mergedSchema = copy(schema);\n    for (let i = 0; i < schema.allOf.length; i += 1) {\n        const allOfSchema = resolveSchema(draft, schema.allOf[i], data);\n        mergedSchema = mergeArraysUnique(mergedSchema, allOfSchema);\n        data = draft.getTemplate(data, mergedSchema);\n    }\n    delete mergedSchema.allOf;\n    return mergedSchema;\n}\n","import { errorOrPromise } from \"./utils/filter\";\nimport flattenArray from \"./utils/flattenArray\";\nimport getTypeOf from \"./getTypeOf\";\nimport settings from \"./config/settings\";\nimport { JSONSchema, JSONPointer, JSONError, isJSONError } from \"./types\";\nimport { Draft as Core } from \"./draft\";\n\nconst { DECLARATOR_ONEOF } = settings;\n\n/**\n * Returns a ranking for the data and given schema\n *\n * @param core\n * @param - json schema type: object\n * @param data\n * @param [pointer]\n * @return ranking value (higher is better)\n */\nfunction fuzzyObjectValue(\n    core: Core,\n    one: JSONSchema,\n    data: { [p: string]: any },\n    pointer?: JSONPointer\n) {\n    if (data == null || one.properties == null) {\n        return -1;\n    }\n\n    let value = 0;\n    const keys = Object.keys(one.properties);\n    for (let i = 0; i < keys.length; i += 1) {\n        const key = keys[i];\n        if (data[key] != null && core.isValid(data[key], one.properties[key], pointer)) {\n            value += 1;\n        }\n    }\n\n    return value;\n}\n\n/**\n * Selects and returns a oneOf schema for the given data\n *\n * @param core\n * @param data\n * @param [schema] - current json schema containing property oneOf\n * @param [pointer] - json pointer to data\n * @return oneOf schema or an error\n */\nexport default function resolveOneOf(\n    core: Core,\n    data: any,\n    schema: JSONSchema = core.rootSchema,\n    pointer: JSONPointer = \"#\"\n): JSONSchema | JSONError {\n    // !keyword: oneOfProperty\n    // an additional <DECLARATOR_ONEOF> (default `oneOfProperty`) on the schema will exactly determine the\n    // oneOf value (if set in data)\n\n    // @fixme\n    // abort if no data is given an DECLARATOR_ONEOF is set (used by getChildSchemaSelection)\n    // this case (data != null) should not be necessary\n    if (data != null && schema[DECLARATOR_ONEOF]) {\n        const errors = [];\n        const oneOfProperty = schema[DECLARATOR_ONEOF];\n        const oneOfValue = data[schema[DECLARATOR_ONEOF]];\n\n        if (oneOfValue === undefined) {\n            return core.errors.missingOneOfPropertyError({ property: oneOfProperty, pointer });\n        }\n\n        for (let i = 0; i < schema.oneOf.length; i += 1) {\n            const one = core.resolveRef(schema.oneOf[i]);\n            const oneOfPropertySchema = core.step(oneOfProperty, one, data, pointer);\n\n            if (isJSONError(oneOfPropertySchema)) {\n                return oneOfPropertySchema;\n            }\n\n            let result = flattenArray(core.validate(oneOfValue, oneOfPropertySchema, pointer));\n            result = result.filter(errorOrPromise);\n\n            if (result.length > 0) {\n                errors.push(...result);\n            } else {\n                return one; // return resolved schema\n            }\n        }\n\n        return core.errors.oneOfPropertyError({\n            property: oneOfProperty,\n            value: oneOfValue,\n            pointer,\n            errors\n        });\n    }\n\n    // keyword: oneOf\n    const matches = [];\n    for (let i = 0; i < schema.oneOf.length; i += 1) {\n        const one = core.resolveRef(schema.oneOf[i]);\n        if (core.isValid(data, one, pointer)) {\n            matches.push(one);\n        }\n    }\n\n    if (matches.length === 1) {\n        return matches[0];\n    }\n\n    // fuzzy match oneOf\n    if (getTypeOf(data) === \"object\") {\n        let schemaOfItem;\n        let fuzzyGreatest = 0;\n\n        for (let i = 0; i < schema.oneOf.length; i += 1) {\n            const one = core.resolveRef(schema.oneOf[i]);\n            const fuzzyValue = fuzzyObjectValue(core, one, data);\n\n            if (fuzzyGreatest < fuzzyValue) {\n                fuzzyGreatest = fuzzyValue;\n                schemaOfItem = schema.oneOf[i];\n            }\n        }\n\n        if (schemaOfItem === undefined) {\n            return core.errors.oneOfError({\n                value: JSON.stringify(data),\n                pointer,\n                oneOf: schema.oneOf\n            });\n        }\n\n        return schemaOfItem;\n    }\n\n    if (matches.length > 1) {\n        return core.errors.multipleOneOfError({ matches, data, pointer });\n    }\n\n    return core.errors.oneOfError({ value: JSON.stringify(data), pointer, oneOf: schema.oneOf });\n}\n","import { JSONSchema } from \"./types\";\n\nexport default function resolveRef(schema: JSONSchema, rootSchema: JSONSchema): JSONSchema {\n    if (schema == null || schema.$ref == null) {\n        return schema;\n    }\n\n    if (schema.getRoot) {\n        // we actually always need to resolve the schema like this, since returned subschemas\n        // must resolve relative from their schema\n        const resolvedSchema = schema.getRoot().getRef(schema);\n        // console.log(schema.$ref, \"=>\", resolvedSchema);\n        return resolvedSchema;\n    }\n\n    // tryout - this should never be called, except we missed something\n    const resolvedSchema = rootSchema.getRef(schema);\n    return resolvedSchema;\n}\n","import { JSONSchema } from \"./types\";\n\n\nexport default function resolveRefMerge(schema: JSONSchema, rootSchema: JSONSchema): JSONSchema {\n    if (schema == null || schema.$ref == null) {\n        return schema;\n    }\n\n    const resolvedSchema = rootSchema.getRef(schema);\n    const mergedSchema = Object.assign({}, resolvedSchema, schema);\n    delete mergedSchema.$ref;\n    // @todo the following might not be safe nor incomplete\n    Object.defineProperty(mergedSchema, \"__ref\", { enumerable: false, value: schema.__ref });\n    Object.defineProperty(mergedSchema, \"getRoot\", { enumerable: false, value: schema.getRoot });\n    return mergedSchema;\n}\n\n","import gp from \"@sagold/json-pointer\";\nimport { JSONSchema, JSONPointer, isJSONError } from \"./types\";\nimport { Draft } from \"./draft\";\n\nconst emptyObject = {};\n\n/**\n * Returns the json-schema of a data-json-pointer.\n *\n *  Notes\n *      - Uses draft.step to walk through data and schema\n *\n * @param draft\n * @param pointer - json pointer in data to get the json schema for\n * @param [data] - the data object, which includes the json pointers value. This is optional, as\n *    long as no oneOf, anyOf, etc statement is part of the pointers schema\n * @param [schema] - the json schema to iterate. Defaults to draft.rootSchema\n * @return json schema object of the json-pointer or an error\n */\nexport default function getSchema(\n    draft: Draft,\n    pointer: JSONPointer,\n    data?: unknown,\n    schema: JSONSchema = draft.rootSchema\n): JSONSchema {\n    const frags = gp.split(pointer);\n    schema = draft.resolveRef(schema);\n    return _get(draft, schema, frags, pointer, data);\n}\n\nfunction _get(\n    draft: Draft,\n    schema: JSONSchema,\n    frags: Array<string>,\n    pointer: JSONPointer,\n    data: unknown = emptyObject\n): JSONSchema {\n    if (frags.length === 0) {\n        return draft.resolveRef(schema);\n    }\n\n    const key = frags.shift(); // step key\n    schema = draft.step(key, schema, data, pointer); // step schema\n    if (isJSONError(schema)) {\n        return schema;\n    }\n    // @ts-ignore\n    data = data[key]; // step data\n    return _get(draft, schema, frags, `${pointer}/${key}`, data);\n}\n","import step from \"../step\";\nimport validate from \"../validate\";\nimport resolveOneOf from \"../resolveOneOf.strict\";\nimport resolveRef from \"../resolveRef.strict\";\nimport resolveAllOf from \"../resolveAllOf\";\nimport resolveAnyOf from \"../resolveAnyOf\";\nimport getTemplate, { TemplateOptions } from \"../getTemplate\";\nimport getChildSchemaSelection from \"../getChildSchemaSelection\";\nimport getSchema from \"../getSchema\";\nimport { each, EachCallback } from \"../each\";\nimport isValid from \"../isValid\";\nimport { eachSchema, EachSchemaCallback } from \"../eachSchema\";\nimport createSchemaOf from \"../createSchemaOf\";\nimport compileSchema from \"../compileSchema\";\nimport { CreateError } from \"../utils/createCustomError\";\nimport addRemoteSchema from \"../addRemoteSchema\";\nimport { JSONSchema, JSONPointer, JSONValidator, JSONTypeValidator, JSONError } from \"../types\";\n\nexport type DraftConfig = {\n    /** error creators by id */\n    errors: Record<string, CreateError>;\n    /** map for valid keywords of a type  */\n    typeKeywords: Record<string, string[]>;\n    /** keyword validators  */\n    validateKeyword: Record<string, JSONValidator>;\n    /** type validators  */\n    validateType: Record<string, JSONTypeValidator>;\n    /** format validators  */\n    validateFormat: Record<string, JSONValidator>;\n\n    addRemoteSchema: typeof addRemoteSchema;\n    compileSchema: typeof compileSchema;\n    createSchemaOf: typeof createSchemaOf;\n    each: typeof each;\n    eachSchema: typeof eachSchema;\n    getChildSchemaSelection: typeof getChildSchemaSelection;\n    getSchema: typeof getSchema;\n    getTemplate: typeof getTemplate;\n    isValid: typeof isValid;\n    resolveAllOf: typeof resolveAllOf;\n    resolveAnyOf: typeof resolveAnyOf;\n    resolveOneOf: typeof resolveOneOf;\n    resolveRef: typeof resolveRef;\n    step: typeof step;\n    validate: typeof validate;\n};\n\nexport class Draft {\n    readonly config: DraftConfig;\n    /** entry point of schema */\n    private __rootSchema: JSONSchema;\n    /** cache for remote schemas */\n    remotes: Record<string, JSONSchema> = {};\n    /** error creators by id */\n    readonly errors: Record<string, CreateError> = {};\n    /** map for valid keywords of a type  */\n    readonly typeKeywords: Record<string, string[]> = {};\n    /** keyword validators  */\n    readonly validateKeyword: Record<string, JSONValidator> = {};\n    /** type validators  */\n    readonly validateType: Record<string, JSONTypeValidator> = {};\n    /** format validators  */\n    readonly validateFormat: Record<string, JSONValidator> = {};\n\n    constructor(config: DraftConfig, schema?: JSONSchema) {\n        this.config = config;\n        this.typeKeywords = JSON.parse(JSON.stringify(config.typeKeywords));\n        this.validateKeyword = Object.assign({}, config.validateKeyword);\n        this.validateType = Object.assign({}, config.validateType);\n        this.validateFormat = Object.assign({}, config.validateFormat);\n        this.errors = Object.assign({}, config.errors);\n        this.setSchema(schema);\n    }\n\n    get rootSchema() {\n        return this.__rootSchema;\n    }\n\n    set rootSchema(rootSchema: JSONSchema) {\n        if (rootSchema == null) {\n            return;\n        }\n        this.__rootSchema = this.config.compileSchema(this, rootSchema);\n    }\n\n    /**\n     * register a json-schema to be referenced from another json-schema\n     * @param url - base-url of json-schema (aka id)\n     * @param schema - json-schema root\n     */\n    addRemoteSchema(url: string, schema: JSONSchema): void {\n        this.config.addRemoteSchema(this, url, schema);\n    }\n\n    compileSchema(schema: JSONSchema): JSONSchema {\n        return this.config.compileSchema(this, schema, this.rootSchema ?? schema);\n    }\n\n    createSchemaOf(data: unknown) {\n        return this.config.createSchemaOf(data);\n    }\n\n    /**\n     * Iterates over data, retrieving its schema\n     *\n     * @param data - the data to iterate\n     * @param callback - will be called with (schema, data, pointer) on each item\n     * @param [schema] - the schema matching the data. Defaults to rootSchema\n     * @param [pointer] - pointer to current data. Default to rootPointer\n     */\n    each(data: any, callback: EachCallback, schema?: JSONSchema, pointer?: JSONPointer) {\n        return this.config.each(this, data, callback, schema, pointer);\n    }\n\n    eachSchema(callback: EachSchemaCallback, schema = this.rootSchema) {\n        return this.config.eachSchema(schema, callback);\n    }\n\n    getChildSchemaSelection(property: string | number, schema?: JSONSchema) {\n        return this.config.getChildSchemaSelection(this, property, schema);\n    }\n\n    /**\n     * Returns the json-schema of a data-json-pointer.\n     * Notes\n     *   - Uses core.step to walk through data and schema\n     *\n     * @param pointer - json pointer in data to get the json schema for\n     * @param [data] - the data object, which includes the json pointers value. This is optional, as\n     *    long as no oneOf, anyOf, etc statement is part of the pointers schema\n     * @param [schema] - the json schema to iterate. Defaults to core.rootSchema\n     * @return json schema object of the json-pointer or an error\n     */\n    getSchema(pointer: JSONPointer = \"#\", data?: any, schema?: JSONSchema): JSONSchema | JSONError {\n        return this.config.getSchema(this, pointer, data, schema);\n    }\n\n    /**\n     * Create data object matching the given schema\n     *\n     * @param [data] - optional template data\n     * @param [schema] - json schema, defaults to rootSchema\n     * @return created template data\n     */\n    getTemplate(data?: unknown, schema?: JSONSchema, opts?: TemplateOptions) {\n        return this.config.getTemplate(this, data, schema, opts);\n    }\n\n    isValid(data: any, schema?: JSONSchema, pointer?: JSONPointer): boolean {\n        return this.config.isValid(this, data, schema, pointer);\n    }\n\n    resolveAnyOf(data: any, schema: JSONSchema, pointer?: JSONPointer): JSONSchema {\n        return this.config.resolveAnyOf(this, data, schema, pointer);\n    }\n\n    resolveAllOf(data: any, schema: JSONSchema, pointer?: JSONPointer): JSONSchema {\n        return this.config.resolveAllOf(this, data, schema, pointer);\n    }\n\n    resolveRef(schema: JSONSchema): JSONSchema {\n        return this.config.resolveRef(schema, this.rootSchema);\n    }\n\n    resolveOneOf(data: any, schema: JSONSchema, pointer?: JSONPointer): JSONSchema {\n        return this.config.resolveOneOf(this, data, schema, pointer);\n    }\n\n    setSchema(schema: JSONSchema) {\n        this.rootSchema = schema;\n    }\n\n    /**\n     * Returns the json-schema of the given object property or array item.\n     * e.g. it steps by one key into the data\n     *\n     *  This helper determines the location of the property within the schema (additional properties, oneOf, ...) and\n     *  returns the correct schema.\n     *\n     * @param  key       - property-name or array-index\n     * @param  schema    - json schema of current data\n     * @param  data      - parent of key\n     * @param  [pointer] - pointer to schema and data (parent of key)\n     * @return Schema or Error if failed resolving key\n     */\n    step(key: string | number, schema: JSONSchema, data: any, pointer?: JSONPointer): JSONSchema {\n        return this.config.step(this, key, schema, data, pointer);\n    }\n\n    /**\n     * Validate data by a json schema\n     *\n     * @param value - value to validate\n     * @param [schema] - json schema, defaults to rootSchema\n     * @param [pointer] - json pointer pointing to value (used for error-messages only)\n     * @return list of errors or empty\n     */\n    validate(data: unknown, schema?: JSONSchema, pointer?: JSONPointer): JSONError[] {\n        return this.config.validate(this, data, schema, pointer);\n    }\n}\n","import { Draft } from \"./draft\";\nimport { JSONSchema } from \"./types\";\n\n/**\n * register a json-schema to be referenced from another json-schema\n * @param url    base-url of json-schema (aka id)\n * @param schema\n */\nexport default function addRemoteSchema(draft: Draft, url: string, schema: JSONSchema): void {\n    schema.id = schema.id || url;\n    draft.remotes[url] = draft.compileSchema(schema);\n}\n","export const propertyRegex = \"[^?/{}*,()#]+\";\n// W3C ENBF grammar\n// https://github.com/lys-lang/node-ebnf/blob/master/test/W3CEBNF.spec.ts\n// https://www.w3.org/TR/xml/#sec-notation\nexport const jsonQueryGrammar = `\nroot ::= (\"#\" recursion | recursion | (query | pattern) recursion* | \"#\" SEP? | SEP)\nrecursion ::= (SEP query | pattern)*\n\nquery ::= (ESC escaped ESC | property | all | any | regex) typecheck? lookahead?\nproperty ::= ${propertyRegex}\nregex ::= \"{\" [^}]+ \"}\"\nSEP ::= \"/\"\nall ::= \"**\"\nany ::= \"*\"\n\ntypecheck ::= \"?:\" (\"value\" | \"boolean\" | \"string\" | \"number\" | \"object\" | \"array\")\nlookahead ::= \"?\" expression ((andExpr | orExpr) expression)*\nandExpr ::= S? \"&&\" S?\norExpr ::= S? \"||\" S?\n\nexpression ::= (exprProperty | ESC escaped ESC) ((isnot | is) (exprProperty | regex | ESC escaped ESC))*\nexprProperty ::= [a-zA-Z0-9-_ $]+\nescaped ::= [^\"]+\nis ::= \":\"\nisnot ::= \":!\"\nESC ::= '\"'\n\npattern ::= S? \"(\" (SEP query | pattern (orPattern? pattern)*)* \")\" quantifier? S? lookahead?\nquantifier ::= \"+\" | \"*\" | [0-9]+\norPattern ::= S? \",\" S?\n\nS ::= [ ]*\n`;\n","import EBNF from \"ebnf/dist/Grammars/W3CEBNF\";\nimport { jsonQueryGrammar } from \"./jsonQueryGrammar\";\nconst valid = /(children|text|type|start|end|rest|errors|fullText|\\d+)/;\nconst subset = /(children|text|type|\\d+)/;\nconst toJSON = (ast) => JSON.stringify(ast, (key, value) => (key === \"\" || valid.test(key) ? value : undefined), 2);\nconst toSmallJSON = (ast) => JSON.stringify(ast, (key, value) => key === \"\" || (key === \"rest\" && value !== \"\") || subset.test(key)\n    ? value\n    : undefined, 2);\nconst parser = new EBNF.Parser(jsonQueryGrammar);\nexport const parse = (query) => parser.getAST(query);\nexport const reduce = (ast) => JSON.parse(toSmallJSON(ast));\nexport { toJSON };\n","const join = (a, b) => `${a}/${b}`;\nimport { VALUE_INDEX, POINTER_INDEX } from \"./keys\";\nconst toString = Object.prototype.toString;\nconst rContainer = /Object|Array/;\nconst isContainer = (v) => rContainer.test(toString.call(v));\nconst getTypeOf = (v) => toString\n    .call(v)\n    .match(/\\s([^\\]]+)\\]/)\n    .pop()\n    .toLowerCase();\nfunction nodeAsRegex(node) {\n    return new RegExp(node.text.replace(/(^{|}$)/g, \"\"));\n}\n/**\n * Iterates over object or array, passing each key, value and parentObject to the callback\n * @param value - to iterate\n * @param callback - receiving key on given input value\n */\nfunction forEach(parent, callback) {\n    if (Array.isArray(parent)) {\n        parent.forEach(callback);\n    }\n    else if (Object.prototype.toString.call(parent) === \"[object Object]\") {\n        Object.keys(parent).forEach(function (key) {\n            callback(parent[key], key, parent);\n        });\n    }\n}\n/**\n * Returns all keys of the given input data\n * @param  value\n * @return {Array} containing keys of given value\n */\nfunction getKeys(value) {\n    if (Array.isArray(value)) {\n        return value.map(function (value, index) {\n            return `${index}`;\n        });\n    }\n    if (Object.prototype.toString.call(value) === \"[object Object]\") {\n        return Object.keys(value);\n    }\n    return [];\n}\nconst cache = {\n    mem: [],\n    get(entry, prop) {\n        const v = entry[VALUE_INDEX][prop];\n        if (cache.mem.includes(v)) {\n            return undefined;\n        }\n        if (isContainer(v)) {\n            cache.mem.push(v);\n        }\n        return [v, prop, entry[VALUE_INDEX], join(entry[POINTER_INDEX], prop)];\n    },\n    reset() {\n        cache.mem.length = 0;\n    },\n};\nconst expand = {\n    any(node, entry) {\n        const value = entry[VALUE_INDEX];\n        return (getKeys(value)\n            // .map(prop => cache.get(entry, prop));\n            .map((prop) => [\n            value[prop],\n            prop,\n            value,\n            join(entry[POINTER_INDEX], prop),\n        ]));\n    },\n    all(node, entry) {\n        const result = [entry];\n        forEach(entry[VALUE_INDEX], (value, prop) => {\n            const childEntry = cache.get(entry, prop);\n            // const childEntry = [value, prop, entry[VALUE_INDEX], join(entry[POINTER_INDEX], prop)];\n            childEntry && result.push(...expand.all(node, childEntry));\n        });\n        return result;\n    },\n    regex(node, entry) {\n        const regex = nodeAsRegex(node);\n        const value = entry[VALUE_INDEX];\n        return getKeys(value)\n            .filter((prop) => regex.test(prop))\n            .map((prop) => [\n            value[prop],\n            prop,\n            value,\n            join(entry[POINTER_INDEX], prop),\n        ]);\n    },\n};\nconst select = {\n    // alias to property (but escaped)\n    escaped: (node, entry) => select.property(node, entry),\n    property: (node, entry) => {\n        const prop = node.text;\n        if (entry[VALUE_INDEX] && entry[VALUE_INDEX][prop] !== undefined) {\n            return [\n                entry[VALUE_INDEX][prop],\n                prop,\n                entry[VALUE_INDEX],\n                join(entry[POINTER_INDEX], prop),\n            ];\n        }\n    },\n    typecheck: (node, entry) => {\n        const checkedTyped = node.text.replace(/^\\?:/, \"\");\n        if (checkedTyped === \"value\") {\n            return isContainer(entry[VALUE_INDEX]) ? undefined : entry;\n        }\n        const type = getTypeOf(entry[VALUE_INDEX]);\n        if (type === checkedTyped) {\n            return entry;\n        }\n    },\n    lookahead: (node, entry) => {\n        let valid = true;\n        let or = false;\n        node.children.forEach((expr) => {\n            if (expr.type === \"expression\") {\n                const isValid = select.expression(expr, entry) !== undefined;\n                valid = or === true ? valid || isValid : valid && isValid;\n            }\n            else {\n                or = expr.type === \"orExpr\";\n            }\n        });\n        return valid ? entry : undefined;\n    },\n    expression: (node, entry) => {\n        const prop = node.children[0].text;\n        const cmp = node.children[1];\n        const test = node.children[2];\n        const value = entry[VALUE_INDEX];\n        if (isContainer(value) === false) {\n            return undefined;\n        }\n        return expressionMatches(value[prop], cmp, test) ? entry : undefined;\n    },\n};\nfunction expressionMatches(value, cmp, test) {\n    if (cmp === undefined) {\n        return value !== undefined;\n    }\n    let valid;\n    const valueString = `${value}`;\n    if (test.type === \"regex\") {\n        const regex = nodeAsRegex(test);\n        valid = regex.test(valueString);\n    }\n    else {\n        valid = valueString === test.text;\n    }\n    if (cmp.type === \"isnot\") {\n        valid = valid === false && value !== undefined;\n    }\n    return valid;\n}\nexport { expand, select, cache };\n","export const VALUE_INDEX = 0;\nexport const KEY_INDEX = 1;\nexport const PARENT_INDEX = 2;\nexport const POINTER_INDEX = 3;\n","import { expand, select, cache } from \"./nodes\";\nimport { VALUE_INDEX, KEY_INDEX, PARENT_INDEX, POINTER_INDEX } from \"./keys\";\nfunction collect(func, input, node, pointer) {\n    const result = [];\n    for (let i = 0, l = input.length; i < l; i += 1) {\n        result.push(...func(node, input[i], node, pointer));\n    }\n    return result;\n}\nfunction reduce(func, input, node, pointer) {\n    const result = [];\n    for (let i = 0, l = input.length; i < l; i += 1) {\n        const output = func(node, input[i], pointer);\n        if (output) {\n            result.push(output);\n        }\n    }\n    return result;\n}\nfunction query(data, ast, pointer) {\n    let result = data;\n    ast.children.forEach((node) => {\n        if (expand[node.type]) {\n            result = collect(expand[node.type], result, node, pointer);\n        }\n        else if (select[node.type]) {\n            result = reduce(select[node.type], result, node, pointer);\n        }\n        else {\n            throw new Error(`Unknown filter ${node.type}`);\n        }\n    });\n    return result;\n}\nfunction runPatternOnce(inputSet, ast, pointer) {\n    const resultingSet = [];\n    let workingSet = inputSet;\n    ast.children.forEach((node) => {\n        if (node.type === \"orPattern\") {\n            resultingSet.push(...workingSet);\n            workingSet = inputSet;\n            return;\n        }\n        workingSet = runNode(workingSet, node, pointer);\n    });\n    resultingSet.push(...workingSet);\n    return resultingSet;\n}\nfunction getIterationCount(quantifier) {\n    if (quantifier == null) {\n        return 1; // default, simple group\n    }\n    if (quantifier === \"*\" || quantifier === \"+\") {\n        return Infinity;\n    }\n    const count = parseInt(quantifier);\n    return isNaN(count) ? 1 : count;\n}\nfunction pattern(data, ast, pointer) {\n    const result = [];\n    const quantifier = ast.children.find((node) => node.type === \"quantifier\");\n    const iterationCount = getIterationCount(quantifier && quantifier.text);\n    let workingSet = data;\n    if (quantifier && quantifier.text === \"*\") {\n        result.push(...workingSet);\n    }\n    let count = 0;\n    while (workingSet.length > 0 && count < iterationCount) {\n        workingSet = runPatternOnce(workingSet, ast, pointer);\n        result.push(...workingSet);\n        count += 1;\n    }\n    return result;\n}\nfunction skip(data, ast, pointer) {\n    let result = data;\n    ast.children.forEach((n) => (result = runNode(result, n, pointer)));\n    return result;\n}\nfunction runNode(data, ast, pointer) {\n    let result;\n    if (ast.type === \"query\") {\n        result = query(data, ast, pointer);\n    }\n    else if (ast.type === \"pattern\") {\n        result = pattern(data, ast, pointer);\n    }\n    else {\n        result = skip(data, ast, pointer);\n    }\n    // after each query or pattern, reset the cache, to (re)enable nested queries\n    cache.reset();\n    cache.mem.push(data);\n    return result;\n}\nexport function run(data, ast) {\n    cache.reset();\n    cache.mem.push(data);\n    return runNode([[data, null, null, \"#\"]], ast);\n}\nexport { VALUE_INDEX, KEY_INDEX, PARENT_INDEX, POINTER_INDEX };\n","import { parse } from \"./parser\";\nimport { run, VALUE_INDEX, POINTER_INDEX } from \"./interpreter\";\nconst returnTypes = {\n    value: (r) => r.map((e) => e[VALUE_INDEX]),\n    pointer: (r) => r.map((e) => e[POINTER_INDEX]),\n    all: (r) => r,\n    map: (r) => {\n        const map = {};\n        r.forEach((e) => (map[e[POINTER_INDEX]] = e[VALUE_INDEX]));\n        return map;\n    },\n};\nexport var ReturnType;\n(function (ReturnType) {\n    ReturnType[\"POINTER\"] = \"pointer\";\n    ReturnType[\"VALUE\"] = \"value\";\n    ReturnType[\"ALL\"] = \"all\";\n    ReturnType[\"MAP\"] = \"map\";\n})(ReturnType || (ReturnType = {}));\n// export return types on function\nget.POINTER = ReturnType.POINTER;\nget.VALUE = ReturnType.VALUE;\nget.ALL = ReturnType.ALL;\nget.MAP = ReturnType.MAP;\n/**\n * Runs query on input data and returns the results\n * @param data - input data\n * @param queryString - json-query string\n * @param returnType - result format or a custom callback\n */\nexport function get(data, queryString, returnType = ReturnType.VALUE) {\n    if (queryString == null) {\n        return [];\n    }\n    queryString = queryString.replace(/(\\/$)/g, \"\");\n    if (queryString === \"\") {\n        queryString = \"#\";\n    }\n    const ast = parse(queryString);\n    if (ast == null) {\n        throw new Error(`empty ast for '${queryString}'`);\n    }\n    if (ast.rest !== \"\") {\n        throw new Error(`Failed parsing queryString from: '${ast.rest}'`);\n    }\n    const result = run(data, ast);\n    if (typeof returnType === \"function\") {\n        return result.map((r) => returnType(...r));\n    }\n    else if (returnTypes[returnType]) {\n        return returnTypes[returnType](result);\n    }\n    return result;\n}\n","import { parse } from \"./parser\";\nconst skip = [\"root\", \"recursion\"];\nfunction buildPath(node, path = []) {\n    if (skip.includes(node.type)) {\n        node.children.forEach((n) => buildPath(n, path));\n        return path;\n    }\n    // remove escaped property quotes?\n    path.push(node.text);\n    return path;\n}\n/**\n * Returns queryString as a list of property-queries\n */\nexport function split(queryString) {\n    if (queryString == null || queryString === \"\") {\n        return [];\n    }\n    const ast = parse(queryString);\n    // console.log(toJSON(ast, null, 2));\n    return buildPath(ast);\n}\n","import { get, ReturnType } from \"./get\";\nimport { propertyRegex } from \"./parser/jsonQueryGrammar\";\nimport { split } from \"./split\";\nconst cp = (v) => JSON.parse(JSON.stringify(v));\nconst toString = Object.prototype.toString;\nconst getType = (v) => toString\n    .call(v)\n    .match(/\\s([^\\]]+)\\]/)\n    .pop()\n    .toLowerCase();\nconst isProperty = new RegExp(`^(\"[^\"]+\"|${propertyRegex})$`);\nconst ignoreTypes = [\"string\", \"number\", \"boolean\", \"null\"];\nconst isArray = /^\\[\\d*\\]$/;\nconst arrayHasIndex = /^\\[(\\d+)\\]$/;\nconst isEscaped = /^\".+\"$/;\nconst isArrayProp = /(^\\[\\d*\\]$|^\\d+$)/;\nfunction convertToIndex(index) {\n    return parseInt(index.replace(/^(\\[|\\]$)/, \"\"));\n}\nfunction removeEscape(property) {\n    return isEscaped.test(property)\n        ? property.replace(/(^\"|\"$)/g, \"\")\n        : property;\n}\nfunction insert(array, index, value) {\n    if (array.length <= index) {\n        array[index] = value;\n    }\n    else {\n        array.splice(index, 0, value);\n    }\n}\nfunction select(workingSet, query) {\n    const nextSet = [];\n    workingSet.forEach((d) => nextSet.push(...get(d[0], query, ReturnType.ALL)));\n    return nextSet;\n}\nfunction addToArray(result, index, value, force) {\n    const target = result[0];\n    // append?\n    if (/^\\[\\]$/.test(index)) {\n        target.push(value);\n        const i = target.length - 1;\n        return [target[i], i, target, `${result[3]}/${i}}`];\n    }\n    // MERGE_ITEMS?\n    if (force == null &&\n        getType(target[index]) === \"object\" &&\n        getType(value) === \"object\") {\n        return [target[index], index, target, `${result[3]}/${index}}`];\n    }\n    if (force === set.INSERT_ITEMS ||\n        (force == null && arrayHasIndex.test(index))) {\n        const arrayIndex = convertToIndex(index);\n        insert(target, arrayIndex, value);\n        return [\n            target[arrayIndex],\n            arrayIndex,\n            target,\n            `${result[3]}/${arrayIndex}}`,\n        ];\n    }\n    if (force === set.REPLACE_ITEMS || force == null) {\n        const arrayIndex = convertToIndex(index);\n        target[arrayIndex] = value;\n        return [\n            target[arrayIndex],\n            arrayIndex,\n            target,\n            `${result[3]}/${arrayIndex}}`,\n        ];\n    }\n    throw new Error(`Unknown array index '${index}' with force-option '${force}'`);\n}\nfunction create(workingSet, query, keyIsArray, force) {\n    query = removeEscape(query);\n    return workingSet\n        .filter((o) => {\n        // replacing or inserting array\n        if (Array.isArray(o[0]) && isArrayProp.test(query)) {\n            return true;\n        }\n        return ignoreTypes.includes(getType(o[0][query])) === false;\n    })\n        .map((r) => {\n        const container = keyIsArray ? [] : {};\n        const o = r[0];\n        if (Array.isArray(o)) {\n            return addToArray(r, query, container, force);\n        }\n        o[query] = o[query] || container;\n        return [o[query], query, o, `${r[3]}/${query}`];\n    });\n}\nexport var InsertMode;\n(function (InsertMode) {\n    InsertMode[\"REPLACE_ITEMS\"] = \"replace\";\n    InsertMode[\"INSERT_ITEMS\"] = \"insert\";\n})(InsertMode || (InsertMode = {}));\n// for all array-indices within path, replace the values, ignoring insertion syntax /[1]/\nset.REPLACE_ITEMS = InsertMode.REPLACE_ITEMS;\n// for all array-indices within path, insert the values, ignoring replace syntax /1/\nset.INSERT_ITEMS = InsertMode.INSERT_ITEMS;\n// set.MERGE_ITEMS = \"merge\";\n/**\n * Runs query on input data and assigns a value to query-results.\n * @param data - input data\n * @param queryString - json-query string\n * @param value - value to assign\n * @param [force] - whether to replace or insert into arrays\n */\nexport function set(data, queryString, value, force) {\n    if (queryString == null) {\n        return cp(data);\n    }\n    queryString = queryString.replace(/(\\/$)/g, \"\");\n    if (queryString === \"\") {\n        return cp(value);\n    }\n    const result = cp(data);\n    let workingSet = [[result, null, null, \"#\"]];\n    const path = split(queryString);\n    const property = path.pop();\n    const arrayWithoutIndex = isArray.test(property) && arrayHasIndex.test(property) === false;\n    if (isProperty.test(property) === false || arrayWithoutIndex) {\n        throw new Error(`Unsupported query '${queryString}' ending with non-property`);\n    }\n    path.forEach((query, index) => {\n        if (\"__proto__\" === query ||\n            \"prototyped\" === query ||\n            \"constructor\" === query) {\n            return;\n        }\n        if (isProperty.test(query) === false) {\n            workingSet = select(workingSet, query);\n            return;\n        }\n        // process property & missing data-structure\n        const nextKey = index >= path.length - 1 ? property : path[index + 1];\n        const insertArray = isArrayProp.test(nextKey);\n        workingSet = create(workingSet, query, insertArray, force);\n    });\n    workingSet.forEach((r) => {\n        let targetValue = value;\n        if (getType(value) === \"function\") {\n            targetValue = value(r[3], property, r[0], `${r[3]}/${property}`);\n        }\n        const d = r[0];\n        if (Array.isArray(d)) {\n            addToArray(r, property, targetValue, force);\n        }\n        else {\n            const unescapedProp = removeEscape(property);\n            if (\"__proto__\" === unescapedProp ||\n                \"prototyped\" === unescapedProp ||\n                \"constructor\" === unescapedProp) {\n                return;\n            }\n            d[unescapedProp] = targetValue;\n        }\n    });\n    return result;\n}\n","import { get, ReturnType } from \"./lib/get\";\nimport { set } from \"./lib/set\";\nimport { split } from \"./lib/split\";\nimport { remove } from \"./lib/remove\";\nexport { get, set, split, remove, ReturnType };\nexport default { get, set, split, remove, ReturnType };\n","export type Type = {\n    type: boolean;\n    definitions?: string[];\n    validationKeywords?: string[];\n    keywords?: string[];\n};\n\nconst Types: Record<string, Type> = {\n    $ref: {\n        type: false\n    },\n    allOf: {\n        type: false,\n        definitions: [\"allOf/*\"]\n    },\n    anyOf: {\n        type: false,\n        definitions: [\"anyOf/*\"]\n    },\n    array: {\n        type: true,\n        // ignore additionalItems:TypeDef, when items:TypeDef\n        definitions: [\n            \"allOf/*\",\n            \"anyOf/*\",\n            \"oneOf/*\",\n            \"not\",\n            \"items\",\n            \"items/*\",\n            \"additionalItems\"\n        ],\n        validationKeywords: [\"minItems\", \"maxItems\", \"uniqueItems\"],\n        keywords: [\"items\", \"additionalItems\", \"minItems\", \"maxItems\", \"uniqueItems\"]\n    },\n    boolean: {\n        type: true\n    },\n    enum: {\n        type: false\n    },\n    integer: {\n        type: true,\n        definitions: [\"allOf/*\", \"anyOf/*\", \"oneOf/*\", \"not\"],\n        validationKeywords: [\"minimum\", \"maximum\", \"multipleOf\"]\n    },\n    not: {\n        type: false,\n        definitions: [\"not\"]\n    },\n    number: {\n        type: true,\n        definitions: [\"allOf/*\", \"anyOf/*\", \"oneOf/*\", \"not\"],\n        validationKeywords: [\"minimum\", \"maximum\", \"multipleOf\"]\n    },\n    null: {\n        type: true\n    },\n    object: {\n        type: true,\n        // patternProperties also validate properties\n        // dependencies:(string, TypeDef) extend current TypeDef\n        // additional Properties validate only remaining properties (after properties & pattern)\n        definitions: [\n            \"allOf/*\",\n            \"anyOf/*\",\n            \"oneOf/*\",\n            \"not\",\n            \"properties/*\",\n            \"additionalProperties\",\n            \"patternProperties/*\",\n            \"dependencies/*\"\n        ],\n        validationKeywords: [\"minProperties\", \"maxProperties\", \"required\"],\n        keywords: [\n            \"properties\",\n            \"additionalProperties\",\n            \"patternProperties\",\n            \"dependencies\",\n            \"minProperties\",\n            \"maxProperties\",\n            \"required\"\n        ]\n    },\n    oneOf: {\n        type: false,\n        definitions: [\"oneOf/*\"]\n    },\n    string: {\n        type: true,\n        definitions: [\"allOf/*\", \"anyOf/*\", \"oneOf/*\", \"not\"],\n        validationKeywords: [\"minLength\", \"maxLength\", \"pattern\"]\n    }\n};\n\nexport default Types;\n","import types from \"./types\";\nimport { JSONSchema } from \"../types\";\n\nconst isObject = (value: unknown) => Object.prototype.toString.call(value) === \"[object Object]\";\nconst typeKeywords = Object.keys(types).filter((id) => types[id].type === false);\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * @throws Error    on multiple matches (invalid schema)\n *\n * Returns the type id of a schema object\n * @param schema\n * @return type id, if found\n */\nexport default function getTypeId(schema: JSONSchema): string | string[] | undefined {\n    if (isObject(schema) === false) {\n        return undefined;\n    }\n\n    if (schema.enum) {\n        return \"enum\";\n    }\n\n    // @ts-ignore\n    if (types[schema.type] || Array.isArray(schema.type)) {\n        return schema.type;\n    }\n\n    const ids = typeKeywords.filter((type) => schema[type]);\n\n    if (ids.length === 1) {\n        return ids[0];\n    }\n\n    if (ids.length === 0) {\n        // @expensive, guess type object\n        for (let i = 0, l = types.object.keywords.length; i < l; i += 1) {\n            const keyword = types.object.keywords[i];\n            if (hasOwnProperty.call(schema, keyword)) {\n                // eslint-disable-line\n                return \"object\";\n            }\n        }\n\n        // @expensive, guess type array\n        for (let i = 0, l = types.array.keywords.length; i < l; i += 1) {\n            const keyword = types.array.keywords[i];\n            if (hasOwnProperty.call(schema, keyword)) {\n                // eslint-disable-line\n                return \"array\";\n            }\n        }\n\n        return undefined;\n    }\n\n    throw new Error(`Mutiple typeIds [${ids.join(\", \")}] matched in ${JSON.stringify(schema)}`);\n}\n","import gp from \"@sagold/json-pointer\";\nimport { get } from \"@sagold/json-query\";\nimport getTypeId from \"./getTypeId\";\nimport types from \"./types\";\nimport { JSONSchema, JSONPointer } from \"../types\";\n\nconst isObject = (value: unknown) => Object.prototype.toString.call(value) === \"[object Object]\";\n\ntype TypeDef = { pointer: JSONPointer; def: unknown };\n\n/**\n * Returns a list of all (direct) type definitions from the given schema\n * @param schema\n * @return list of type definition, given as { pointer, def }\n */\nexport default function getTypeDefs(schema: JSONSchema): TypeDef[] {\n    const defs: TypeDef[] = [];\n    const id = getTypeId(schema);\n    if (id == null) {\n        return defs;\n    }\n\n    let type;\n    if (Array.isArray(id)) {\n        // since types can also be declared as a set of types, merge the definitions\n        // maybe this will require a more sophisticated approach\n        type = {};\n        for (let i = 0, l = id.length; i < l; i += 1) {\n            Object.assign(type, types[id[i]]);\n        }\n    } else {\n        type = types[id];\n    }\n\n    if (type.definitions == null) {\n        return defs;\n    }\n\n    type.definitions.forEach((query: string) => {\n        get(schema, query, (value: unknown, key, parent, pointer) => {\n            if (isObject(value) && getTypeId(value)) {\n                defs.push({ pointer: gp.join(gp.split(pointer), false), def: value });\n            }\n        });\n    });\n\n    return defs;\n}\n","import gp from \"@sagold/json-pointer\";\nimport getTypeDefs from \"./schema/getTypeDefs\";\nimport { JSONSchema, JSONPointer } from \"./types\";\n\nexport type EachSchemaCallback = (schema: JSONSchema, pointer: JSONPointer) => void;\n\ntype Walker = {\n    nextTypeDefs: typeof nextTypeDefs;\n    callback: EachSchemaCallback;\n};\n\nconst isObject = (value: unknown): value is Record<string, unknown> =>\n    Object.prototype.toString.call(value) === \"[object Object]\";\n\nfunction nextTypeDefs(schema: JSONSchema, pointer: JSONPointer) {\n    if (this.callback(schema, pointer) === true) {\n        // eslint-disable-line no-invalid-this\n        return; // stop iteration\n    }\n\n    const defs = getTypeDefs(schema);\n    // eslint-disable-next-line no-invalid-this\n    defs.forEach((next) => this.nextTypeDefs(next.def, gp.join(pointer, next.pointer, false)));\n}\n\nfunction eachDefinition(\n    walk: Walker,\n    schema: JSONSchema,\n    pointer: JSONPointer,\n    key = \"definitions\"\n) {\n    const defs = schema[key];\n    Object.keys(defs).forEach((defId) => {\n        if (defs[defId] === false || isObject(defs[defId])) {\n            walk.nextTypeDefs(defs[defId], gp.join(pointer, key, defId, false));\n            return;\n        }\n        // console.log(`Invalid schema in ${pointer}/${key}/${defId}`);\n    });\n}\n\nexport function eachSchema(\n    schema: JSONSchema,\n    callback: EachSchemaCallback,\n    pointer: JSONPointer = \"#\"\n) {\n    const walk = { callback, nextTypeDefs };\n    walk.nextTypeDefs(schema, pointer);\n\n    if (schema.definitions != null) {\n        walk.callback = (defschema, schemaPointer) => {\n            callback(defschema, schemaPointer);\n            if (defschema.definitions != null) {\n                eachDefinition(walk, defschema, schemaPointer);\n            }\n        };\n\n        eachDefinition(walk, schema, pointer);\n    }\n\n    if (schema.$defs != null) {\n        walk.callback = (defschema, schemaPointer) => {\n            callback(defschema, schemaPointer);\n            if (defschema.definitions != null) {\n                eachDefinition(walk, defschema, schemaPointer);\n            }\n        };\n\n        eachDefinition(walk, schema, pointer, \"$defs\");\n    }\n}\n","/* eslint max-statements-per-line: [\"error\", { \"max\": 2 }] */\nconst suffixes = /(#|\\/)+$/;\nconst trailingHash = /#$/;\nconst isDomain = /^[^:]+:\\/\\/[^/]+\\//;\nconst trailingFragments = /\\/[^/]*$/;\nconst idAndPointer = /#.*$/;\n\n\nexport default function joinScope(previous?: string, id?: string) {\n    if (previous == null && id == null) { return \"#\"; }\n    if (id == null) { return previous.replace(trailingHash, \"\"); }\n    if (previous == null) { return id.replace(trailingHash, \"\"); }\n    if (id[0] === \"#\") { return `${previous.replace(idAndPointer, \"\")}${id.replace(suffixes, \"\")}`; }\n    if (isDomain.test(id)) { return id.replace(trailingHash, \"\"); }\n    return `${previous.replace(trailingFragments, \"\")}/${id.replace(trailingHash, \"\")}`;\n}\n","const suffixes = /(#|\\/)+$/g;\nconst emptyValues = [\"\", null, \"#\"];\n\n\nexport default function splitRef($ref: string) {\n    if (emptyValues.includes($ref)) {\n        return [];\n    }\n\n    $ref = $ref.replace(suffixes, \"\");\n    if ($ref.indexOf(\"#\") === -1) {\n        return [$ref.replace(suffixes, \"\")];\n    }\n\n    if ($ref.indexOf(\"#\") === 0) {\n        return [$ref.replace(suffixes, \"\")];\n    }\n\n    const result = $ref.split(\"#\");\n    result[0] = result[0].replace(suffixes, \"\");\n    result[1] = `#${result[1].replace(suffixes, \"\")}`;\n    return result;\n}\n","import { get } from \"@sagold/json-pointer\";\nimport splitRef from \"./splitRef\";\nimport getTypeOf from \"../getTypeOf\";\nimport { JSONSchema } from \"../types\";\nimport { Context } from \"./types\";\n\nconst suffixes = /(#|\\/)+$/g;\nconst isObject = (val: unknown): val is Record<string, any> => getTypeOf(val) === \"object\";\n\n// 1. combined is known\n// 2. base or pointer is known\n// 3. base + pointer is known\nexport default function getRef(context: Context, rootSchema: JSONSchema, $ref: string): JSONSchema {\n    if (isObject($ref)) {\n        $ref = $ref.__ref || $ref.$ref;\n    }\n\n    if ($ref == null) {\n        return rootSchema;\n    }\n\n    let schema;\n\n    // is it a known $ref?\n    const $remote = $ref.replace(suffixes, \"\");\n    if (context.remotes[$remote]) {\n        schema = context.remotes[$remote];\n        if (schema && schema.$ref) {\n            return getRef(context, rootSchema, schema.$ref);\n        }\n        return schema;\n    }\n    if (context.ids[$ref]) {\n        schema = get(rootSchema, context.ids[$ref]);\n        if (schema && schema.$ref) {\n            return getRef(context, rootSchema, schema.$ref);\n        }\n        return schema;\n    }\n\n    // is it a ref with host/pointer?\n    const fragments = splitRef($ref);\n    if (fragments.length === 0) {\n        return rootSchema;\n    }\n\n    if (fragments.length === 1) {\n        $ref = fragments[0];\n        if (context.remotes[$ref]) {\n            schema = context.remotes[$ref];\n            return getRef(context, rootSchema, schema.$ref);\n        }\n        if (context.ids[$ref]) {\n            schema = get(rootSchema, context.ids[$ref]);\n            if (schema && schema.$ref) {\n                return getRef(context, rootSchema, schema.$ref);\n            }\n            return schema;\n        }\n    }\n\n    if (fragments.length === 2) {\n        const base = fragments[0];\n        $ref = fragments[1];\n\n        if (context.remotes[base]) {\n            if (context.remotes[base].getRef) {\n                return context.remotes[base].getRef($ref);\n            }\n            // console.log(\"warning: uncompiled remote - context may be wrong\", base);\n            return getRef(context, context.remotes[base], $ref);\n        }\n        if (context.ids[base]) {\n            return getRef(context, get(rootSchema, context.ids[base]), $ref);\n        }\n    }\n\n    schema = get(rootSchema, context.ids[$ref] || $ref);\n    if (schema && schema.$ref) {\n        return getRef(context, rootSchema, schema.$ref);\n    }\n    return schema;\n}\n","/* eslint max-statements-per-line: [\"error\", { \"max\": 2 }] */\nimport { Draft } from \"../../draft\";\nimport { eachSchema } from \"../../eachSchema\";\n// import remotes from \"../../../remotes\";\nimport joinScope from \"../../compile/joinScope\";\nimport getRef from \"../../compile/getRef\";\nimport { JSONSchema } from \"../../types\";\nimport { get } from \"@sagold/json-pointer\";\n\nconst COMPILED = \"__compiled\";\nconst COMPILED_REF = \"__ref\";\nconst GET_REF = \"getRef\";\nconst GET_ROOT = \"getRoot\";\nconst suffixes = /(#|\\/)+$/g;\n\ntype Context = {\n    ids: Record<string, unknown>;\n    remotes: Record<string, JSONSchema>;\n};\n\n/**\n * @draft starting with _draft 06_ keyword `id` has been renamed to `$id`\n *\n * compiles the input root schema for $ref resolution and returns it again\n * @attention this modifies input schema but maintains object-structure\n *\n * for a compiled json-schema you can call getRef on any contained schema (location of type).\n * this resolves a $ref target to a valid schema (for a valid $ref)\n *\n * @param rootSchema root json-schema ($id, defs, ... ) to compile\n * @param [force] = false force compile json-schema\n * @return compiled json-schema\n */\nexport default function compileSchema(\n    draft: Draft,\n    schemaToCompile: JSONSchema,\n    rootSchema = schemaToCompile,\n    force = false\n): JSONSchema {\n    // @ts-ignore\n    if (schemaToCompile === true || schemaToCompile === false || schemaToCompile === undefined) {\n        return schemaToCompile;\n    }\n    if (schemaToCompile[COMPILED] !== undefined) {\n        return schemaToCompile;\n    } // eslint-disable-line\n    const context: Context = { ids: {}, remotes: draft.remotes };\n    const rootSchemaAsString = JSON.stringify(schemaToCompile);\n    const compiledSchema = JSON.parse(rootSchemaAsString);\n    Object.defineProperty(compiledSchema, COMPILED, { enumerable: false, value: true });\n    Object.defineProperty(compiledSchema, GET_REF, {\n        enumerable: false,\n        value: getRef.bind(null, context, compiledSchema)\n    });\n\n    // bail early, when no $refs are defined\n    if (force === false && rootSchemaAsString.includes(\"$ref\") === false) {\n        return compiledSchema;\n    }\n\n    // compile this schema under rootSchema, making definitions available to $ref-resolution\n    if (compiledSchema !== rootSchema) {\n        Object.defineProperty(compiledSchema, \"$defs\", {\n            enumerable: true,\n            value: Object.assign(\n                {},\n                rootSchema.definitions,\n                rootSchema.$defs,\n                compiledSchema.definitions,\n                compiledSchema.$defs\n            )\n        });\n    }\n\n    const scopes: Record<string, string> = {};\n    const getRoot = () => compiledSchema;\n    eachSchema(compiledSchema, (schema, pointer) => {\n        if (schema.$id) {\n            // if this is a schema being merged on root object, we cannot override\n            // parents locations, but must reuse it\n            if (schema.$id.startsWith(\"http\") && /(allOf|anyOf|oneOf)\\/\\d+$/.test(pointer)) {\n                const parentPointer = pointer.replace(/\\/(allOf|anyOf|oneOf)\\/\\d+$/, \"\");\n                const parentSchema = get(compiledSchema, parentPointer);\n                schema.$id = parentSchema.$id ?? schema.$id;\n            }\n            context.ids[schema.$id.replace(suffixes, \"\")] = pointer;\n        }\n\n        // build up scopes and add them to $ref-resolution map\n        pointer = `#${pointer}`.replace(/##+/, \"#\");\n        const previousPointer = pointer.replace(/\\/[^/]+$/, \"\");\n        const parentPointer = pointer.replace(/\\/[^/]+\\/[^/]+$/, \"\");\n        const previousScope = scopes[previousPointer] || scopes[parentPointer];\n        const scope = joinScope(previousScope, schema.$id);\n        scopes[pointer] = scope;\n        if (context.ids[scope] == null) {\n            context.ids[scope] = pointer;\n        }\n\n        if (schema.$ref && !schema[COMPILED_REF]) {\n            Object.defineProperty(schema, COMPILED_REF, {\n                enumerable: false,\n                value: joinScope(scope, schema.$ref)\n            });\n            // @todo currently not used:\n            Object.defineProperty(schema, GET_ROOT, { enumerable: false, value: getRoot });\n            // console.log(\"compiled ref\", scope, schema.$ref, \"=>\", joinScope(scope, schema.$ref));\n        }\n    });\n\n    return compiledSchema;\n}\n","import { Draft as Core } from \"./draft\";\nimport getTypeOf from \"./getTypeOf\";\nimport { JSONSchema, JSONPointer } from \"./types\";\n\nexport type EachCallback = (schema: JSONSchema, data: unknown, pointer: JSONPointer) => void;\n\n/**\n * Iterates over data, retrieving its schema\n *\n * @param core - validator\n * @param data - the data to iterate\n * @param callback - will be called with (schema, data, pointer) on each item\n * @param [schema] - the schema matching the data. Defaults to rootSchema\n * @param [pointer] - pointer to current data. Default to rootPointer\n */\nexport function each(\n    core: Core,\n    data: any,\n    callback: EachCallback,\n    schema: JSONSchema = core.rootSchema,\n    pointer: JSONPointer = \"#\"\n) {\n    schema = core.resolveRef(schema);\n    callback(schema, data, pointer);\n    const dataType = getTypeOf(data);\n\n    if (dataType === \"object\") {\n        Object.keys(data).forEach((key) => {\n            const nextSchema = core.step(key, schema, data, pointer); // not save\n            const next = data[key]; // save\n            core.each(next, callback, nextSchema, `${pointer}/${key}`);\n        });\n    } else if (dataType === \"array\") {\n        data.forEach((next: unknown, key: number) => {\n            const nextSchema = core.step(key, schema, data, pointer);\n            core.each(next, callback, nextSchema, `${pointer}/${key}`);\n        });\n    }\n}\n","/* eslint no-invalid-this: 0 */\nimport { createCustomError, CreateError } from \"../utils/createCustomError\";\n\nconst errors: Record<string, CreateError> = {\n    additionalItemsError: createCustomError(\"AdditionalItemsError\"),\n    additionalPropertiesError: createCustomError(\"AdditionalPropertiesError\"),\n    anyOfError: createCustomError(\"AnyOfError\"),\n    allOfError: createCustomError(\"AllOfError\"),\n    constError: createCustomError(\"ConstError\"),\n    containsError: createCustomError(\"ContainsError\"),\n    containsArrayError: createCustomError(\"ContainsArrayError\"),\n    containsAnyError: createCustomError(\"ContainsAnyError\"),\n    enumError: createCustomError(\"EnumError\"),\n    formatURLError: createCustomError(\"FormatURLError\"),\n    formatURIError: createCustomError(\"FormatURIError\"),\n    formatURIReferenceError: createCustomError(\"FormatURIReferenceError\"),\n    formatURITemplateError: createCustomError(\"FormatURITemplateError\"),\n    formatDateError: createCustomError(\"FormatDateaError\"),\n    formatDateTimeError: createCustomError(\"FormatDateTimeError\"),\n    formatEmailError: createCustomError(\"FormatEmailError\"),\n    formatHostnameError: createCustomError(\"FormatHostnameError\"),\n    formatIPV4Error: createCustomError(\"FormatIPV4Error\"),\n    formatIPV4LeadingZeroError: createCustomError(\"FormatIPV4LeadingZeroError\"),\n    formatIPV6Error: createCustomError(\"FormatIPV6Error\"),\n    formatIPV6LeadingZeroError: createCustomError(\"FormatIPV6LeadingZeroError\"),\n    formatJSONPointerError: createCustomError(\"FormatJSONPointerError\"),\n    formatRegExError: createCustomError(\"FormatRegExError\"),\n    formatTimeError: createCustomError(\"FormatTimeError\"),\n    invalidSchemaError: createCustomError(\"InvalidSchemaError\"),\n    invalidDataError: createCustomError(\"InvalidDataError\"),\n    invalidTypeError: createCustomError(\"InvalidTypeError\"),\n    invalidPropertyNameError: createCustomError(\"InvalidPropertyNameError\"),\n    maximumError: createCustomError(\"MaximumError\"),\n    maxItemsError: createCustomError(\"MaxItemsError\"),\n    maxLengthError: createCustomError(\"MaxLengthError\"),\n    maxPropertiesError: createCustomError(\"MaxPropertiesError\"),\n    minimumError: createCustomError(\"MinimumError\"),\n    minItemsError: createCustomError(\"MinItemsError\"),\n    minItemsOneError: createCustomError(\"MinItemsOneError\"),\n    minLengthError: createCustomError(\"MinLengthError\"),\n    minLengthOneError: createCustomError(\"MinLengthOneError\"),\n    minPropertiesError: createCustomError(\"MinPropertiesError\"),\n    missingDependencyError: createCustomError(\"MissingDependencyError\"),\n    missingOneOfPropertyError: createCustomError(\"MissingOneOfPropertyError\"),\n    multipleOfError: createCustomError(\"MultipleOfError\"),\n    multipleOneOfError: createCustomError(\"MultipleOneOfError\"),\n    noAdditionalPropertiesError: createCustomError(\"NoAdditionalPropertiesError\"),\n    notError: createCustomError(\"NotError\"),\n    oneOfError: createCustomError(\"OneOfError\"),\n    oneOfPropertyError: createCustomError(\"OneOfPropertyError\"),\n    patternError: createCustomError(\"PatternError\"),\n    patternPropertiesError: createCustomError(\"PatternPropertiesError\"),\n    requiredPropertyError: createCustomError(\"RequiredPropertyError\"),\n    typeError: createCustomError(\"TypeError\"),\n    undefinedValueError: createCustomError(\"UndefinedValueError\"),\n    uniqueItemsError: createCustomError(\"UniqueItemsError\"),\n    unknownPropertyError: createCustomError(\"UnknownPropertyError\"),\n    valueNotEmptyError: createCustomError(\"ValueNotEmptyError\")\n};\n\nexport default errors;\n","/* eslint-disable max-len, no-control-regex */\nimport errors from \"./errors\";\nimport { JSONError, JSONSchema } from \"../types\";\nimport { Draft } from \"../draft\";\nimport validUrl from \"valid-url\";\n\n// referenced\n// https://github.com/cfworker/cfworker/blob/main/packages/json-schema/src/format.ts\n\n// https://gist.github.com/marcelotmelo/b67f58a08bee6c2468f8\nconst isValidDateTime = new RegExp(\n    \"^([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\\\.[0-9]+)?(([Zz])|([\\\\+|\\\\-]([01][0-9]|2[0-3]):[0-5][0-9]))$\"\n);\nconst isValidIPV4 = /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/;\nconst isValidIPV6 =\n    /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i;\nconst isValidHostname =\n    /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/;\nconst matchDate = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;\nconst matchTime = /^(\\d\\d):(\\d\\d):(\\d\\d)(\\.\\d+)?(z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\nconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\nconst isValidJSONPointer = /^(?:\\/(?:[^~/]|~0|~1)*)*$/;\nconst isValidRelativeJSONPointer = /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/;\nconst isValidURIRef =\n    /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\n// uri-template: https://tools.ietf.org/html/rfc6570\nconst isValidURITemplate =\n    /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i;\n\n// Default JSON-Schema formats: date-time, email, hostname, ipv4, ipv6, uri, uriref\nconst formatValidators: Record<\n    string,\n    (\n        draft: Draft,\n        schema: JSONSchema,\n        value: unknown,\n        pointer: string\n    ) => undefined | JSONError | JSONError[]\n> = {\n    date: (core, schema, value, pointer) => {\n        if (typeof value !== \"string\") {\n            return undefined;\n        }\n        // https://github.com/cfworker/cfworker/blob/main/packages/json-schema/src/format.ts\n        // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n        const matches = value.match(matchDate);\n        if (!matches) {\n            return errors.formatDateTimeError({ value, pointer });\n        }\n        const year = +matches[1];\n        const month = +matches[2];\n        const day = +matches[3];\n        // https://tools.ietf.org/html/rfc3339#appendix-C\n        const isLeapYear = year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n        if (\n            month >= 1 &&\n            month <= 12 &&\n            day >= 1 &&\n            day <= (month == 2 && isLeapYear ? 29 : DAYS[month])\n        ) {\n            return undefined;\n        }\n        return errors.formatDateError({ value, pointer });\n    },\n\n    \"date-time\": (core, schema, value, pointer) => {\n        if (typeof value !== \"string\") {\n            return undefined;\n        }\n        if (value === \"\" || isValidDateTime.test(value)) {\n            if (new Date(value).toString() === \"Invalid Date\") {\n                return errors.formatDateTimeError({ value, pointer });\n            }\n            return undefined;\n        }\n        return errors.formatDateTimeError({ value, pointer });\n    },\n\n    email: (core, schema, value, pointer) => {\n        // taken from https://github.com/ExodusMovement/schemasafe/blob/master/src/formats.js\n        if (typeof value !== \"string\") {\n            return undefined;\n        }\n        if (value[0] === '\"') {\n            return errors.formatEmailError({ value, pointer });\n        }\n        const [name, host, ...rest] = value.split(\"@\");\n        if (!name || !host || rest.length !== 0 || name.length > 64 || host.length > 253) {\n            return errors.formatEmailError({ value, pointer });\n        }\n        if (name[0] === \".\" || name.endsWith(\".\") || name.includes(\"..\")) {\n            return errors.formatEmailError({ value, pointer });\n        }\n        if (!/^[a-z0-9.-]+$/i.test(host) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(name)) {\n            return errors.formatEmailError({ value, pointer });\n        }\n        if (!host.split(\".\").every((part) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part))) {\n            return errors.formatEmailError({ value, pointer });\n        }\n        return undefined;\n    },\n\n    hostname: (core, schema, value, pointer) => {\n        if (typeof value !== \"string\") {\n            return undefined;\n        }\n        if (value === \"\" || isValidHostname.test(value)) {\n            return undefined;\n        }\n        return errors.formatHostnameError({ value, pointer });\n    },\n\n    ipv4: (core, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (value && value[0] === \"0\") {\n            // leading zeroes should be rejected, as they are treated as octals\n            return errors.formatIPV4LeadingZeroError({ value, pointer });\n        }\n        if (value.length <= 15 && isValidIPV4.test(value)) {\n            return undefined;\n        }\n        return errors.formatIPV4Error({ value, pointer });\n    },\n\n    ipv6: (core, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (value && value[0] === \"0\") {\n            // leading zeroes should be rejected, as they are treated as octals\n            return errors.formatIPV6LeadingZeroError({ value, pointer });\n        }\n        if (value.length <= 45 && isValidIPV6.test(value)) {\n            return undefined;\n        }\n        return errors.formatIPV6Error({ value, pointer });\n    },\n\n    \"json-pointer\": (core, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (isValidJSONPointer.test(value)) {\n            return undefined;\n        }\n        return errors.formatJSONPointerError({ value, pointer });\n    },\n\n    \"relative-json-pointer\": (core, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (isValidRelativeJSONPointer.test(value)) {\n            return undefined;\n        }\n        return errors.formatJSONPointerError({ value, pointer });\n    },\n\n    regex: (core, schema, value, pointer) => {\n        if (typeof value === \"string\" && /\\\\Z$/.test(value) === false) {\n            try {\n                new RegExp(value);\n                return undefined;\n            } catch (e) {} // eslint-disable-line no-empty\n\n            return errors.formatRegExError({ value, pointer });\n        }\n        // v7 tests, ignore non-regex values\n        if (typeof value === \"object\" || typeof value === \"number\" || Array.isArray(value)) {\n            return undefined;\n        }\n        return errors.formatRegExError({ value, pointer });\n    },\n\n    time: (core, schema, value, pointer) => {\n        if (typeof value !== \"string\") {\n            return undefined;\n        }\n        // https://github.com/cfworker/cfworker/blob/main/packages/json-schema/src/format.ts\n        const matches = value.match(matchTime);\n        if (!matches) {\n            return errors.formatDateTimeError({ value, pointer });\n        }\n        const hour = +matches[1];\n        const minute = +matches[2];\n        const second = +matches[3];\n        const timeZone = !!matches[5];\n        if (\n            ((hour <= 23 && minute <= 59 && second <= 59) ||\n                (hour == 23 && minute == 59 && second == 60)) &&\n            timeZone\n        ) {\n            return undefined;\n        }\n        return errors.formatTimeError({ value, pointer });\n    },\n\n    uri: (core, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (validUrl.isUri(value)) {\n            return undefined;\n        }\n        return errors.formatURIError({ value, pointer });\n    },\n\n    \"uri-reference\": (core, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (isValidURIRef.test(value)) {\n            return undefined;\n        }\n        return errors.formatURIReferenceError({ value, pointer });\n    },\n\n    \"uri-template\": (core, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (isValidURITemplate.test(value)) {\n            return undefined;\n        }\n        return errors.formatURITemplateError({ value, pointer });\n    },\n\n    url: (core, schema, value: string, pointer) => {\n        if (value === \"\" || validUrl.isWebUri(value)) {\n            return undefined;\n        }\n        return errors.formatURLError({ value, pointer });\n    }\n};\n\nexport default formatValidators;\n","/* eslint quote-props: 0, max-statements-per-line: [\"error\", { \"max\": 2 }] */\nimport resolveOneOfFuzzy from \"./resolveOneOf.fuzzy\";\nimport getTypeOf from \"./getTypeOf\";\nimport merge from \"./utils/merge\";\nimport copy from \"./utils/copy\";\nimport settings from \"./config/settings\";\nimport { JSONSchema, JSONPointer, isJSONError } from \"./types\";\nimport { Draft as Core } from \"./draft\";\nimport { isEmpty } from \"./utils/isEmpty\";\n\nexport type TemplateOptions = {\n    /** Add all properties (required and optional) to the generated data */\n    addOptionalProps?: boolean;\n    /** remove data that does not match input schema. Defaults to false */\n    removeInvalidData?: boolean;\n};\n\nconst defaultOptions: TemplateOptions = {\n    addOptionalProps: true,\n    removeInvalidData: false\n};\n\nlet cache: Record<string, JSONSchema>;\nfunction shouldResolveRef(schema: JSONSchema, pointer: JSONPointer) {\n    const { $ref } = schema;\n    if ($ref == null) {\n        return true;\n    }\n\n    const value = cache[pointer] == null || cache[pointer][$ref] == null ? 0 : cache[pointer][$ref];\n    return value < settings.GET_TEMPLATE_RECURSION_LIMIT;\n}\n\nfunction resolveRef(core: Core, schema: JSONSchema, pointer: JSONPointer) {\n    // ensure we refactored consistently\n    if (pointer == null) {\n        throw new Error(`missing pointer ${pointer}`);\n    }\n\n    const { $ref } = schema;\n    if ($ref == null) {\n        return schema;\n    }\n\n    // @todo pointer + ref is redundant?\n    cache[pointer] = cache[pointer] || {};\n    cache[pointer][$ref] = cache[pointer][$ref] || 0;\n    cache[pointer][$ref] += 1;\n    return core.resolveRef(schema);\n}\n\nfunction convertValue(type: string, value: any) {\n    if (type === \"string\") {\n        return JSON.stringify(value);\n    } else if (typeof value !== \"string\") {\n        return null;\n    }\n    try {\n        value = JSON.parse(value);\n        if (typeof value === type) {\n            return value;\n        }\n    } catch (e) {} // eslint-disable-line no-empty\n    return null;\n}\n\n/**\n * Resolves $ref, allOf and anyOf schema-options, returning a combined json-schema.\n * Also returns a pointer-property on schema, that must be used as current pointer.\n * @param core\n * @param schema\n * @param data\n * @param pointer\n * @return resolved json-schema or input-schema\n */\nfunction createTemplateSchema(\n    core: Core,\n    schema: JSONSchema,\n    data: unknown,\n    pointer: JSONPointer\n): JSONSchema | false {\n    // invalid schema\n    if (getTypeOf(schema) !== \"object\") {\n        return Object.assign({ pointer }, schema);\n    }\n    // return if reached recursion limit\n    if (shouldResolveRef(schema, pointer) === false && data == null) {\n        return false;\n    }\n\n    // resolve $ref and copy schema\n    let templateSchema = copy(resolveRef(core, schema, pointer));\n\n    if (Array.isArray(schema.anyOf) && schema.anyOf.length > 0) {\n        // test if we may resolve\n        if (shouldResolveRef(schema.anyOf[0], `${pointer}/anyOf/0`)) {\n            const resolvedAnyOf = resolveRef(core, schema.anyOf[0], `${pointer}/anyOf/0`);\n            templateSchema = merge(templateSchema, resolvedAnyOf);\n            // add pointer return-value, if any\n            templateSchema.pointer = schema.anyOf[0].$ref || templateSchema.pointer;\n        }\n        delete templateSchema.anyOf;\n    }\n\n    // resolve allOf\n    if (Array.isArray(schema.allOf)) {\n        for (let i = 0, l = schema.allOf.length; i < l; i += 1) {\n            // test if we may resolve\n            if (shouldResolveRef(schema.allOf[i], `${pointer}/allOf/${i}`)) {\n                templateSchema = merge(\n                    templateSchema,\n                    resolveRef(core, schema.allOf[i], `${pointer}/allOf/${i}`)\n                );\n                // add pointer return-value, if any\n                templateSchema.pointer = schema.allOf[i].$ref || templateSchema.pointer;\n            }\n        }\n        delete templateSchema.allOf;\n    }\n\n    templateSchema.pointer = templateSchema.pointer || schema.$ref || pointer;\n    return templateSchema;\n}\n\nconst isJSONSchema = (template: unknown): template is JSONSchema =>\n    template && typeof template === \"object\";\n\n/**\n * Create data object matching the given schema\n *\n * @param core - json schema core\n * @param [data] - optional template data\n * @param [schema] - json schema, defaults to rootSchema\n * @return created template data\n */\nfunction getTemplate(\n    core: Core,\n    data?: unknown,\n    _schema?: JSONSchema,\n    pointer?: JSONPointer,\n    opts?: TemplateOptions\n) {\n    if (_schema == null) {\n        throw new Error(`getTemplate: missing schema for data: ${JSON.stringify(data)}`);\n    }\n    if (pointer == null) {\n        throw new Error(\"Missing pointer\");\n    }\n\n    // resolve $ref references, allOf and first anyOf definitions\n    let schema = createTemplateSchema(core, _schema, data, pointer);\n    if (!isJSONSchema(schema)) {\n        return undefined;\n    }\n    pointer = schema.pointer;\n\n    if (schema?.const) {\n        return schema.const;\n    }\n\n    if (Array.isArray(schema.oneOf)) {\n        if (isEmpty(data)) {\n            const type =\n                schema.oneOf[0].type ||\n                schema.type ||\n                (schema.const && typeof schema.const) ||\n                getTypeOf(data);\n            schema = { ...schema.oneOf[0], type };\n        } else {\n            // find correct schema for data\n            const resolvedSchema = resolveOneOfFuzzy(core, data, schema);\n            if (isJSONError(resolvedSchema)) {\n                if (data != null && opts.removeInvalidData !== true) {\n                    return data;\n                }\n                // override\n                schema = schema.oneOf[0];\n                data = undefined;\n            } else {\n                schema = resolvedSchema;\n            }\n        }\n    }\n\n    // @todo Array.isArray(schema.type)\n    // -> hasDefault? return\n    // if not -> pick first types\n\n    if (!isJSONSchema(schema) || schema.type == null) {\n        return undefined;\n    }\n\n    const type = Array.isArray(schema.type)\n        ? selectType(schema.type, data, schema.default)\n        : schema.type;\n\n    // reset invalid type\n    const dataType = getTypeOf(data);\n    if (data != null && dataType !== type && !(dataType === \"number\" && type === \"integer\")) {\n        data = convertValue(type, data);\n    }\n\n    if (TYPE[type] == null) {\n        // in case we could not resolve the type\n        // (schema-type could not be resolved and returned an error)\n        if (opts.removeInvalidData) {\n            return undefined;\n        }\n        return data;\n    }\n\n    const templateData = TYPE[type](core, schema, data, pointer, opts);\n    return templateData;\n}\n\nfunction selectType(types: string[], data: unknown, defaultValue: unknown) {\n    if (data == undefined) {\n        if (defaultValue != null) {\n            const defaultType = getTypeOf(defaultValue);\n            if (types.includes(defaultType)) {\n                return defaultType;\n            }\n        }\n        return types[0];\n    }\n    const dataType = getTypeOf(data);\n    if (types.includes(dataType)) {\n        return dataType;\n    }\n    return types[0];\n}\n\nconst TYPE: Record<\n    string,\n    (\n        core: Core,\n        schema: JSONSchema,\n        data: unknown,\n        pointer: JSONPointer,\n        opts: TemplateOptions\n    ) => unknown\n> = {\n    null: (core, schema, data) => getDefault(schema, data, null),\n    string: (core, schema, data) => getDefault(schema, data, \"\"),\n    number: (core, schema, data) => getDefault(schema, data, 0),\n    integer: (core, schema, data) => getDefault(schema, data, 0),\n    boolean: (core, schema, data) => getDefault(schema, data, false),\n    object: (\n        core,\n        schema,\n        data: Record<string, unknown> | undefined,\n        pointer: JSONPointer,\n        opts: TemplateOptions\n    ) => {\n        const template = schema.default === undefined ? {} : schema.default;\n        const d: Record<string, unknown> = {}; // do not assign data here, to keep ordering from json-schema\n        const required = schema.required ?? [];\n\n        if (schema.properties) {\n            Object.keys(schema.properties).forEach((key) => {\n                const value = data == null || data[key] == null ? template[key] : data[key];\n                const isRequired = required.includes(key);\n\n                // Omit adding a property if it is not required or optional props should be added\n                if (value != null || isRequired || opts.addOptionalProps) {\n                    d[key] = getTemplate(\n                        core,\n                        value,\n                        schema.properties[key],\n                        `${pointer}/properties/${key}`,\n                        opts\n                    );\n                }\n            });\n        }\n\n        if (schema.dependencies) {\n            Object.keys(schema.dependencies).forEach((key) => {\n                if (d[key] === undefined) {\n                    return;\n                }\n\n                const dependency = schema.dependencies[key];\n\n                // dependencyRequired: { key: ['prop1', 'prop2'] }\n                if (Array.isArray(dependency)) {\n                    dependency.forEach((prop) => {\n                        d[prop] = getTemplate(\n                            core,\n                            d[prop],\n                            schema.properties[prop],\n                            `${pointer}/properties/${prop}`,\n                            opts\n                        );\n                    });\n                    return;\n                }\n\n                if (getTypeOf(dependency) !== \"object\") {\n                    return;\n                }\n\n                const result = getTemplate(\n                    core,\n                    data,\n                    {\n                        ...dependency,\n                        // required: Object.keys(dependency.properties || {}).concat(\n                        //     dependency.required ?? []\n                        // ),\n                        type: \"object\"\n                    },\n                    `${pointer}/dependencies/${key}`,\n                    opts\n                );\n\n                if (result && !isJSONError(result)) {\n                    Object.assign(d, result);\n                }\n            });\n        }\n\n        if (data) {\n            // merge any missing data (additionals) to resulting object\n            Object.keys(data).forEach((key) => d[key] == null && (d[key] = data[key]));\n        }\n\n        if (schema.if && (schema.then || schema.else)) {\n            const isValid = core.isValid(d, schema.if);\n            if (isValid && schema.then) {\n                const additionalData = core.getTemplate(\n                    d,\n                    { type: \"object\", ...schema.then },\n                    opts\n                );\n                Object.assign(d, additionalData);\n            } else if (!isValid && schema.else) {\n                const additionalData = core.getTemplate(\n                    d,\n                    { type: \"object\", ...schema.else },\n                    opts\n                );\n                Object.assign(d, additionalData);\n            }\n        }\n\n        // returns object, which is ordered by json-schema\n        return d;\n    },\n    // build array type of items, ignores additionalItems\n    array: (\n        core: Core,\n        schema: JSONSchema,\n        data: unknown[],\n        pointer: JSONPointer,\n        opts: TemplateOptions\n    ) => {\n        const template = schema.default === undefined ? [] : schema.default;\n        schema.minItems = schema.minItems || 0;\n\n        const d: unknown[] = data || [];\n\n        // items are undefined\n        if (schema.items == null) {\n            return d;\n        }\n\n        // build defined set of items\n        if (Array.isArray(schema.items)) {\n            for (\n                let i = 0, l = Math.max(schema.minItems ?? 0, schema.items?.length ?? 0);\n                i < l;\n                i += 1\n            ) {\n                d[i] = getTemplate(\n                    core,\n                    d[i] == null ? template[i] : d[i],\n                    schema.items[i],\n                    `${pointer}/items/${i}`,\n                    opts\n                );\n            }\n            return d;\n        }\n\n        // abort if the schema is invalid\n        if (getTypeOf(schema.items) !== \"object\") {\n            return d;\n        }\n\n        // resolve allOf and first anyOf definition\n        const templateSchema = createTemplateSchema(core, schema.items, data, pointer);\n        if (templateSchema === false) {\n            return d;\n        }\n        pointer = templateSchema.pointer || pointer;\n\n        // build oneOf\n        if (templateSchema.oneOf && d.length === 0) {\n            const oneOfSchema = templateSchema.oneOf[0];\n            for (let i = 0; i < schema.minItems; i += 1) {\n                d[i] = getTemplate(\n                    core,\n                    d[i] == null ? template[i] : d[i],\n                    oneOfSchema,\n                    `${pointer}/oneOf/0`,\n                    opts\n                );\n            }\n            return d;\n        }\n\n        if (templateSchema.oneOf && d.length > 0) {\n            const itemCount = Math.max(schema.minItems, d.length);\n            for (let i = 0; i < itemCount; i += 1) {\n                let value = d[i] == null ? template[i] : d[i];\n                let one = resolveOneOfFuzzy(core, value, templateSchema);\n\n                if (one == null || isJSONError(one)) {\n                    // schema could not be resolved or data is invalid\n                    if (value != null && opts.removeInvalidData !== true) {\n                        // keep invalid value\n                        d[i] = value;\n                    } else {\n                        // replace invalid value\n                        value = undefined;\n                        one = templateSchema.oneOf[0];\n                        d[i] = getTemplate(core, value, one, `${pointer}/oneOf/${i}`, opts);\n                    }\n                } else {\n                    // schema is valid\n                    d[i] = getTemplate(core, value, one, `${pointer}/oneOf/${i}`, opts);\n                }\n            }\n            return d;\n        }\n\n        // build items-definition\n        if (templateSchema.type) {\n            for (let i = 0, l = Math.max(schema.minItems, d.length); i < l; i += 1) {\n                d[i] = getTemplate(\n                    core,\n                    d[i] == null ? template[i] : d[i],\n                    templateSchema,\n                    `${pointer}/items`,\n                    opts\n                );\n            }\n            return d;\n        }\n\n        return d;\n    }\n};\n\nfunction getDefault(schema: JSONSchema, templateValue: any, initValue: any) {\n    if (templateValue != null) {\n        return templateValue;\n    } else if (schema.const) {\n        return schema.const;\n    } else if (schema.default === undefined && Array.isArray(schema.enum)) {\n        return schema.enum[0];\n    } else if (schema.default === undefined) {\n        return initValue;\n    }\n    return schema.default;\n}\n\nexport default (\n    core: Core,\n    data?: any,\n    schema: JSONSchema = core.rootSchema,\n    opts: TemplateOptions = defaultOptions\n) => {\n    cache = { mi: {} };\n    return getTemplate(core, data, schema, \"#\", opts);\n};\n","import getTypeOf from \"../getTypeOf\";\n\nexport function isEmpty(v: unknown): boolean {\n    const type = getTypeOf(v);\n    switch (type) {\n        case \"string\":\n        case \"array\":\n            // @ts-ignore\n            return v.length === 0;\n        case \"null\":\n        case \"undefined\":\n            return true;\n        case \"object\":\n            return Object.keys(v).length === 0;\n        default:\n            return false;\n    }\n}\n","import { JSONSchema, JSONPointer } from \"./types\";\nimport { Draft as Core } from \"./draft\";\n\n/**\n * Test if the data is valid according to the given schema\n *\n * @param core - validator\n * @param value - value to validate\n * @param [schema] - json schema\n * @param [pointer] - json pointer pointing to value\n * @return if schema does match given value\n */\nexport default function isValid(\n    core: Core,\n    value: any,\n    schema: JSONSchema = core.rootSchema,\n    pointer: JSONPointer = \"#\"\n): boolean {\n    return core.validate(value, schema, pointer).length === 0;\n}\n","/**\n * deep comparison of javascript types. Better handling than using\n * JSON.stringify, where property order is accounted for\n *\n * @returns true, if data types are deep equal\n */\nexport default function deepCompareStrict(a: any, b: any): boolean {\n    const typeofa = typeof a;\n    if (typeofa !== typeof b) {\n        return false;\n    }\n    if (Array.isArray(a)) {\n        if (!Array.isArray(b)) {\n            return false;\n        }\n        const length = a.length;\n        if (length !== b.length) {\n            return false;\n        }\n        for (let i = 0; i < length; i++) {\n            if (!deepCompareStrict(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (typeofa === \"object\") {\n        if (!a || !b) {\n            return a === b;\n        }\n        const aKeys = Object.keys(a);\n        const bKeys = Object.keys(b);\n        const length = aKeys.length;\n        if (length !== bKeys.length) {\n            return false;\n        }\n        for (const k of aKeys) {\n            if (!deepCompareStrict(a[k], b[k])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return a === b;\n}\n","/* eslint no-bitwise: 0 */\n\n/**\n * taken from punycode@2.1.0\n *\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param string The Unicode input string (UCS-2).\n * @returns The new array of code points.\n */\nexport default function ucs2decode(string: string): string[] {\n    const output = [];\n    let counter = 0;\n    const length = string.length;\n    while (counter < length) {\n        const value = string.charCodeAt(counter++);\n        if (value >= 0xd800 && value <= 0xdbff && counter < length) {\n            // It's a high surrogate, and there is a next character.\n            const extra = string.charCodeAt(counter++);\n            // eslint-disable-next-line eqeqeq\n            if ((extra & 0xfc00) == 0xdc00) {\n                // Low surrogate.\n                output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);\n            } else {\n                // It's an unmatched surrogate; only append this code unit, in case the\n                // next code unit is the high surrogate of a surrogate pair.\n                output.push(value);\n                counter--;\n            }\n        } else {\n            output.push(value);\n        }\n    }\n    return output as unknown as string[];\n}\n","import getTypeOf from \"../getTypeOf\";\nimport isSame from \"../utils/deepCompare\";\nimport settings from \"../config/settings\";\nimport ucs2decode from \"../utils/punycode.ucs2decode\";\nimport { JSONValidator, isJSONError, JSONSchema, JSONError } from \"../types\";\nconst FPP = settings.floatingPointPrecision;\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasProperty = (value: Record<string, unknown>, property: string) =>\n    !(value[property] === undefined || !hasOwnProperty.call(value, property));\n\n// list of validation keywords: http://json-schema.org/latest/json-schema-validation.html#rfc.section.5\nconst KeywordValidation: Record<string, JSONValidator> = {\n    additionalProperties: (core, schema, value: Record<string, unknown>, pointer) => {\n        if (schema.additionalProperties === true || schema.additionalProperties == null) {\n            return undefined;\n        }\n\n        if (\n            getTypeOf(schema.patternProperties) === \"object\" &&\n            schema.additionalProperties === false\n        ) {\n            // this is an arrangement with patternProperties. patternProperties validate before additionalProperties:\n            // https://spacetelescope.github.io/understanding-json-schema/reference/object.html#index-5\n            return undefined;\n        }\n\n        const errors: JSONError[] = [];\n        let receivedProperties = Object.keys(value).filter(\n            (prop) => settings.propertyBlacklist.includes(prop) === false\n        );\n        const expectedProperties = Object.keys(schema.properties || {});\n\n        if (getTypeOf(schema.patternProperties) === \"object\") {\n            // filter received properties by matching patternProperties\n            const patterns = Object.keys(schema.patternProperties).map(\n                (pattern) => new RegExp(pattern)\n            );\n            receivedProperties = receivedProperties.filter((prop) => {\n                for (let i = 0; i < patterns.length; i += 1) {\n                    if (patterns[i].test(prop)) {\n                        return false; // remove\n                    }\n                }\n                return true;\n            });\n        }\n\n        // adds an error for each an unexpected property\n        for (let i = 0, l = receivedProperties.length; i < l; i += 1) {\n            const property = receivedProperties[i];\n            if (expectedProperties.indexOf(property) === -1) {\n                const isObject = typeof schema.additionalProperties === \"object\";\n\n                // additionalProperties { oneOf: [] }\n                if (isObject && Array.isArray(schema.additionalProperties.oneOf)) {\n                    const result = core.resolveOneOf(\n                        value[property],\n                        schema.additionalProperties,\n                        `${pointer}/${property}`\n                    );\n                    if (isJSONError(result)) {\n                        errors.push(\n                            core.errors.additionalPropertiesError({\n                                schema: schema.additionalProperties,\n                                property: receivedProperties[i],\n                                properties: expectedProperties,\n                                pointer,\n                                // pass all validation errors\n                                errors: result.data.errors\n                            })\n                        );\n                    } else {\n                        errors.push(...core.validate(value[property], result, pointer));\n                    }\n\n                    // additionalProperties {}\n                } else if (isObject) {\n                    errors.push(\n                        ...core.validate(\n                            value[property],\n                            schema.additionalProperties,\n                            `${pointer}/${property}`\n                        )\n                    );\n                } else {\n                    errors.push(\n                        core.errors.noAdditionalPropertiesError({\n                            property: receivedProperties[i],\n                            properties: expectedProperties,\n                            pointer\n                        })\n                    );\n                }\n            }\n        }\n\n        return errors;\n    },\n\n    allOf: (core, schema, value, pointer) => {\n        if (Array.isArray(schema.allOf) === false) {\n            return undefined;\n        }\n\n        const errors: JSONError[] = [];\n        schema.allOf.forEach((subSchema: JSONSchema) => {\n            errors.push(...core.validate(value, subSchema, pointer));\n        });\n\n        return errors;\n    },\n\n    anyOf: (core, schema, value, pointer) => {\n        if (Array.isArray(schema.anyOf) === false) {\n            return undefined;\n        }\n\n        for (let i = 0; i < schema.anyOf.length; i += 1) {\n            if (core.isValid(value, schema.anyOf[i])) {\n                return undefined;\n            }\n        }\n\n        return core.errors.anyOfError({ anyOf: schema.anyOf, value, pointer });\n    },\n\n    dependencies: (core, schema, value: Record<string, unknown>, pointer) => {\n        if (getTypeOf(schema.dependencies) !== \"object\") {\n            return undefined;\n        }\n\n        const errors: JSONError[] = [];\n        Object.keys(value).forEach((property) => {\n            if (schema.dependencies[property] === undefined) {\n                return;\n            }\n\n            // @draft >= 6 boolean schema\n            if (schema.dependencies[property] === true) {\n                return;\n            }\n            if (schema.dependencies[property] === false) {\n                errors.push(core.errors.missingDependencyError({ pointer }));\n                return;\n            }\n\n            let dependencyErrors;\n            const type = getTypeOf(schema.dependencies[property]);\n            if (type === \"array\") {\n                dependencyErrors = schema.dependencies[property]\n                    .filter((dependency: any) => value[dependency] === undefined)\n                    .map((missingProperty: any) =>\n                        core.errors.missingDependencyError({ missingProperty, pointer })\n                    );\n            } else if (type === \"object\") {\n                dependencyErrors = core.validate(value, schema.dependencies[property], pointer);\n            } else {\n                throw new Error(\n                    `Invalid dependency definition for ${pointer}/${property}. Must be list or schema`\n                );\n            }\n\n            errors.push(...dependencyErrors);\n        });\n\n        return errors.length > 0 ? errors : undefined;\n    },\n\n    enum: (core, schema, value, pointer) => {\n        const type = getTypeOf(value);\n        if (type === \"object\" || type === \"array\") {\n            const valueStr = JSON.stringify(value);\n            for (let i = 0; i < schema.enum.length; i += 1) {\n                if (JSON.stringify(schema.enum[i]) === valueStr) {\n                    return undefined;\n                }\n            }\n        } else if (schema.enum.includes(value)) {\n            return undefined;\n        }\n        return core.errors.enumError({ values: schema.enum, value, pointer });\n    },\n    format: (core, schema, value, pointer) => {\n        if (core.validateFormat[schema.format]) {\n            const errors = core.validateFormat[schema.format](core, schema, value, pointer);\n            return errors;\n        }\n        // fail silently if given format is not defined\n        return undefined;\n    },\n    items: (core, schema, value: unknown[], pointer) => {\n        // @draft >= 7 bool schema\n        if (schema.items === false) {\n            if (Array.isArray(value) && value.length === 0) {\n                return undefined;\n            }\n            return core.errors.invalidDataError({ pointer, value });\n        }\n\n        const errors: JSONError[] = [];\n        for (let i = 0; i < value.length; i += 1) {\n            const itemData = value[i];\n            // @todo reevaluate: incomplete schema is created here\n            const itemSchema = core.step(i, schema, value, pointer);\n            if (isJSONError(itemSchema)) {\n                return [itemSchema];\n            }\n\n            const itemErrors = core.validate(itemData, itemSchema, `${pointer}/${i}`);\n            errors.push(...itemErrors);\n        }\n\n        return errors;\n    },\n    maximum: (core, schema, value, pointer) => {\n        if (isNaN(schema.maximum)) {\n            return undefined;\n        }\n        if (schema.maximum && schema.maximum < value) {\n            return core.errors.maximumError({ maximum: schema.maximum, length: value, pointer });\n        }\n        if (schema.maximum && schema.exclusiveMaximum === true && schema.maximum === value) {\n            return core.errors.maximumError({ maximum: schema.maximum, length: value, pointer });\n        }\n        return undefined;\n    },\n    maxItems: (core, schema, value: unknown[], pointer) => {\n        if (isNaN(schema.maxItems)) {\n            return undefined;\n        }\n        if (schema.maxItems < value.length) {\n            return core.errors.maxItemsError({\n                maximum: schema.maxItems,\n                length: value.length,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    maxLength: (core, schema, value: string, pointer) => {\n        if (isNaN(schema.maxLength)) {\n            return undefined;\n        }\n        const lengthOfString = ucs2decode(value).length;\n        if (schema.maxLength < lengthOfString) {\n            return core.errors.maxLengthError({\n                maxLength: schema.maxLength,\n                length: lengthOfString,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    maxProperties: (core, schema, value, pointer) => {\n        const propertyCount = Object.keys(value).length;\n        if (isNaN(schema.maxProperties) === false && schema.maxProperties < propertyCount) {\n            return core.errors.maxPropertiesError({\n                maxProperties: schema.maxProperties,\n                length: propertyCount,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    minLength: (core, schema, value: string, pointer) => {\n        if (isNaN(schema.minLength)) {\n            return undefined;\n        }\n        const lengthOfString = ucs2decode(value).length;\n        if (schema.minLength > lengthOfString) {\n            if (schema.minLength === 1) {\n                return core.errors.minLengthOneError({\n                    minLength: schema.minLength,\n                    length: lengthOfString,\n                    pointer\n                });\n            }\n            return core.errors.minLengthError({\n                minLength: schema.minLength,\n                length: lengthOfString,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    minimum: (core, schema, value, pointer) => {\n        if (isNaN(schema.minimum)) {\n            return undefined;\n        }\n        if (schema.minimum > value) {\n            return core.errors.minimumError({ minimum: schema.minimum, length: value, pointer });\n        }\n        if (schema.exclusiveMinimum === true && schema.minimum === value) {\n            return core.errors.minimumError({ minimum: schema.minimum, length: value, pointer });\n        }\n        return undefined;\n    },\n    minItems: (core, schema, value: unknown[], pointer) => {\n        if (isNaN(schema.minItems)) {\n            return undefined;\n        }\n        if (schema.minItems > value.length) {\n            if (schema.minItems === 1) {\n                return core.errors.minItemsOneError({\n                    minItems: schema.minItems,\n                    length: value.length,\n                    pointer\n                });\n            }\n            return core.errors.minItemsError({\n                minItems: schema.minItems,\n                length: value.length,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    minProperties: (core, schema, value, pointer) => {\n        if (isNaN(schema.minProperties)) {\n            return undefined;\n        }\n        const propertyCount = Object.keys(value).length;\n        if (schema.minProperties > propertyCount) {\n            return core.errors.minPropertiesError({\n                minProperties: schema.minProperties,\n                length: propertyCount,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    multipleOf: (core, schema, value: number, pointer) => {\n        if (isNaN(schema.multipleOf)) {\n            return undefined;\n        }\n        // https://github.com/cfworker/cfworker/blob/master/packages/json-schema/src/validate.ts#L1061\n        // https://github.com/ExodusMovement/schemasafe/blob/master/src/compile.js#L441\n        if (((value * FPP) % (schema.multipleOf * FPP)) / FPP !== 0) {\n            return core.errors.multipleOfError({ multipleOf: schema.multipleOf, value, pointer });\n        }\n        // also check https://stackoverflow.com/questions/1815367/catch-and-compute-overflow-during-multiplication-of-two-large-integers\n        return undefined;\n    },\n    not: (core, schema, value, pointer) => {\n        const errors: JSONError[] = [];\n        if (core.validate(value, schema.not, pointer).length === 0) {\n            errors.push(core.errors.notError({ value, not: schema.not, pointer }));\n        }\n        return errors;\n    },\n    oneOf: (core, schema, value, pointer) => {\n        if (Array.isArray(schema.oneOf) === false) {\n            return undefined;\n        }\n\n        schema = core.resolveOneOf(value, schema, pointer);\n        if (isJSONError(schema)) {\n            return schema;\n        }\n\n        return undefined;\n    },\n    pattern: (core, schema, value: string, pointer) => {\n        const pattern = new RegExp(schema.pattern, \"u\");\n        if (pattern.test(value) === false) {\n            return core.errors.patternError({\n                pattern: schema.pattern,\n                description: schema.patternExample || schema.pattern,\n                received: value,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    patternProperties: (core, schema, value: Record<string, unknown>, pointer) => {\n        const properties = schema.properties || {};\n        const pp = schema.patternProperties;\n        if (getTypeOf(pp) !== \"object\") {\n            return undefined;\n        }\n\n        const errors: JSONError[] = [];\n        const keys = Object.keys(value);\n        const patterns = Object.keys(pp).map((expr) => ({\n            regex: new RegExp(expr),\n            patternSchema: pp[expr]\n        }));\n\n        keys.forEach((key) => {\n            let patternFound = false;\n\n            for (let i = 0, l = patterns.length; i < l; i += 1) {\n                if (patterns[i].regex.test(key)) {\n                    patternFound = true;\n                    const valErrors = core.validate(\n                        value[key],\n                        patterns[i].patternSchema,\n                        `${pointer}/${key}`\n                    );\n                    if (valErrors && valErrors.length > 0) {\n                        errors.push(...valErrors);\n                    }\n                }\n            }\n\n            if (properties[key]) {\n                return;\n            }\n\n            if (patternFound === false && schema.additionalProperties === false) {\n                // this is an arrangement with additionalProperties\n                errors.push(\n                    core.errors.patternPropertiesError({\n                        key,\n                        pointer,\n                        patterns: Object.keys(pp).join(\",\")\n                    })\n                );\n            }\n        });\n\n        return errors;\n    },\n    properties: (core, schema, value: Record<string, unknown>, pointer) => {\n        const errors: JSONError[] = [];\n        const keys = Object.keys(schema.properties || {});\n        for (let i = 0; i < keys.length; i += 1) {\n            const key = keys[i];\n            if (hasProperty(value, key)) {\n                const itemSchema = core.step(key, schema, value, pointer);\n                const keyErrors = core.validate(value[key], itemSchema, `${pointer}/${key}`);\n                errors.push(...keyErrors);\n            }\n        }\n        return errors;\n    },\n    // @todo move to separate file: this is custom keyword validation for JsonEditor.properties keyword\n    propertiesRequired: (core, schema, value: Record<string, unknown>, pointer) => {\n        const errors: JSONError[] = [];\n        const keys = Object.keys(schema.properties || {});\n        for (let i = 0; i < keys.length; i += 1) {\n            const key = keys[i];\n            if (value[key] === undefined) {\n                errors.push(core.errors.requiredPropertyError({ key, pointer }));\n            } else {\n                const itemSchema = core.step(key, schema, value, pointer);\n                const keyErrors = core.validate(value[key], itemSchema, `${pointer}/${key}`);\n                errors.push(...keyErrors);\n            }\n        }\n        return errors;\n    },\n    required: (core, schema, value: Record<string, unknown>, pointer) => {\n        if (Array.isArray(schema.required) === false) {\n            return undefined;\n        }\n\n        return schema.required.map((property: string) => {\n            if (!hasProperty(value, property)) {\n                return core.errors.requiredPropertyError({ key: property, pointer });\n            }\n            return undefined;\n        });\n    },\n    // @todo move to separate file: this is custom keyword validation for JsonEditor.required keyword\n    requiredNotEmpty: (core, schema, value: Record<string, unknown>, pointer) => {\n        if (Array.isArray(schema.required) === false) {\n            return undefined;\n        }\n\n        return schema.required.map((property: string) => {\n            if (value[property] == null || value[property] === \"\") {\n                return core.errors.valueNotEmptyError({\n                    property,\n                    pointer: `${pointer}/${property}`\n                });\n            }\n            return undefined;\n        });\n    },\n    uniqueItems: (core, schema, value: unknown[], pointer) => {\n        if ((Array.isArray(value) && schema.uniqueItems) === false) {\n            return undefined;\n        }\n\n        const errors: JSONError[] = [];\n        value.forEach((item, index) => {\n            for (let i = index + 1; i < value.length; i += 1) {\n                if (isSame(item, value[i])) {\n                    errors.push(\n                        core.errors.uniqueItemsError({\n                            pointer,\n                            itemPointer: `${pointer}/${index}`,\n                            duplicatePointer: `${pointer}/${i}`,\n                            value: JSON.stringify(item)\n                        })\n                    );\n                }\n            }\n        });\n\n        return errors;\n    }\n};\n\nexport default KeywordValidation;\n","import Keywords from \"../../validation/keyword\";\nimport getTypeOf from \"../../getTypeOf\";\nimport { JSONValidator, JSONError } from \"../../types\";\n\nconst KeywordValidation: Record<string, JSONValidator> = {\n    ...Keywords,\n    // @draft >= 6\n    contains: (core, schema, value: unknown[], pointer) => {\n        if (schema.contains === false) {\n            return core.errors.containsArrayError({ pointer, value });\n        }\n\n        if (schema.contains === true) {\n            if (Array.isArray(value) && value.length === 0) {\n                return core.errors.containsAnyError({ pointer });\n            }\n            return undefined;\n        }\n\n        if (getTypeOf(schema.contains) !== \"object\") {\n            // ignore invalid schema\n            return undefined;\n        }\n\n        for (let i = 0; i < value.length; i += 1) {\n            if (core.isValid(value[i], schema.contains)) {\n                return undefined;\n            }\n        }\n        return core.errors.containsError({ pointer, schema: JSON.stringify(schema.contains) });\n    },\n    exclusiveMaximum: (core, schema, value, pointer) => {\n        if (isNaN(schema.exclusiveMaximum)) {\n            return undefined;\n        }\n        if (schema.exclusiveMaximum <= value) {\n            return core.errors.maximumError({\n                maximum: schema.exclusiveMaximum,\n                length: value,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    exclusiveMinimum: (core, schema, value, pointer) => {\n        if (isNaN(schema.exclusiveMinimum)) {\n            return undefined;\n        }\n        if (schema.exclusiveMinimum >= value) {\n            return core.errors.minimumError({\n                minimum: schema.exclusiveMinimum,\n                length: value,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    if: (core, schema, value, pointer) => {\n        if (schema.if == null) {\n            return undefined;\n        }\n\n        const ifErrors = core.validate(value, schema.if, pointer);\n        // console.log(\"if Errors\", value, ifErrors);\n\n        if (ifErrors.length === 0 && schema.then) {\n            return core.validate(value, schema.then, pointer);\n        }\n\n        if (ifErrors.length !== 0 && schema.else) {\n            return core.validate(value, schema.else, pointer);\n        }\n    },\n    maximum: (core, schema, value, pointer) => {\n        if (isNaN(schema.maximum)) {\n            return undefined;\n        }\n        if (schema.maximum && schema.maximum < value) {\n            return core.errors.maximumError({ maximum: schema.maximum, length: value, pointer });\n        }\n        return undefined;\n    },\n    minimum: (core, schema, value, pointer) => {\n        if (isNaN(schema.minimum)) {\n            return undefined;\n        }\n        if (schema.minimum > value) {\n            return core.errors.minimumError({ minimum: schema.minimum, length: value, pointer });\n        }\n        return undefined;\n    },\n    patternProperties: (core, schema, value: Record<string, unknown>, pointer) => {\n        const properties = schema.properties || {};\n        const pp = schema.patternProperties;\n        if (getTypeOf(pp) !== \"object\") {\n            return undefined;\n        }\n\n        const errors: JSONError[] = [];\n        const keys = Object.keys(value);\n        const patterns = Object.keys(pp).map((expr) => ({\n            regex: new RegExp(expr),\n            patternSchema: pp[expr]\n        }));\n\n        keys.forEach((key) => {\n            let patternFound = false;\n\n            for (let i = 0, l = patterns.length; i < l; i += 1) {\n                if (patterns[i].regex.test(key)) {\n                    patternFound = true;\n\n                    // for a boolean schema `false`, always invalidate\n                    if (patterns[i].patternSchema === false) {\n                        errors.push(\n                            core.errors.patternPropertiesError({\n                                key,\n                                pointer,\n                                patterns: Object.keys(pp).join(\",\")\n                            })\n                        );\n                        return;\n                    }\n\n                    const valErrors = core.validate(\n                        value[key],\n                        patterns[i].patternSchema,\n                        `${pointer}/${key}`\n                    );\n                    if (valErrors && valErrors.length > 0) {\n                        errors.push(...valErrors);\n                    }\n                }\n            }\n\n            if (properties[key]) {\n                return;\n            }\n\n            if (patternFound === false && schema.additionalProperties === false) {\n                // this is an arrangement with additionalProperties\n                errors.push(\n                    core.errors.patternPropertiesError({\n                        key,\n                        pointer,\n                        patterns: Object.keys(pp).join(\",\")\n                    })\n                );\n            }\n        });\n\n        return errors;\n    },\n    // @draft >= 6\n    propertyNames: (core, schema, value: Record<string, unknown>, pointer) => {\n        // bool schema\n        if (schema.propertyNames === false) {\n            // empty objects are valid\n            if (Object.keys(value).length === 0) {\n                return undefined;\n            }\n            return core.errors.invalidPropertyNameError({\n                property: Object.keys(value),\n                pointer,\n                value\n            });\n        }\n\n        if (schema.propertyNames === true) {\n            return undefined;\n        }\n\n        if (getTypeOf(schema.propertyNames) !== \"object\") {\n            // ignore invalid schema\n            return undefined;\n        }\n\n        const errors: JSONError[] = [];\n        const properties = Object.keys(value);\n        const propertySchema = { ...schema.propertyNames, type: \"string\" };\n        properties.forEach((prop) => {\n            const validationResult = core.validate(prop, propertySchema, `${pointer}/${prop}`);\n            if (validationResult.length > 0) {\n                errors.push(\n                    core.errors.invalidPropertyNameError({\n                        property: prop,\n                        pointer,\n                        validationError: validationResult[0],\n                        value: value[prop]\n                    })\n                );\n            }\n        });\n\n        return errors;\n    }\n};\n\nexport default KeywordValidation;\n","import copy from \"./utils/copy\";\nimport merge from \"./utils/merge\";\nimport errors from \"./validation/errors\";\nimport { JSONSchema, JSONPointer, JSONError } from \"./types\";\nimport { Draft as Core } from \"./draft\";\n\nexport default function resolveAnyOf(\n    core: Core,\n    data: any,\n    schema: JSONSchema = core.rootSchema,\n    pointer: JSONPointer = \"#\"\n): JSONSchema | JSONError {\n    let found = false;\n    let mergedSchema = copy(schema);\n    for (let i = 0; i < schema.anyOf.length; i += 1) {\n        const anyOfSchema = core.resolveRef(schema.anyOf[i]);\n        if (core.isValid(data, schema.anyOf[i], pointer)) {\n            found = true;\n            mergedSchema = merge(mergedSchema, anyOfSchema);\n        }\n    }\n\n    if (found === false) {\n        return errors.anyOfError({ value: data, pointer, anyOf: JSON.stringify(schema.anyOf) });\n    }\n\n    delete mergedSchema.anyOf;\n    return mergedSchema;\n}\n","import getTypeOf from \"./getTypeOf\";\nimport { JSONSchema } from \"./types\";\n\n/**\n * Create a simple json schema for the given input data\n * @param  data - data to get json schema for\n * @return schema\n */\nexport default function createSchemaOf(data: any): JSONSchema {\n    const schema: JSONSchema = {\n        type: getTypeOf(data)\n    };\n\n    if (schema.type === \"object\") {\n        schema.properties = {};\n        Object.keys(data).forEach((key) => (schema.properties[key] = createSchemaOf(data[key])));\n    }\n\n    if (schema.type === \"array\" && data.length === 1) {\n        schema.items = createSchemaOf(data[0]);\n    } else if (schema.type === \"array\") {\n        schema.items = data.map(createSchemaOf);\n    }\n\n    return schema;\n}\n","import { Draft } from \"./draft\";\nimport { isJSONError, JSONError, JSONSchema } from \"./types\";\n\n/**\n * Returns a list of possible child-schemas for the given property key. In case of a oneOf selection, multiple schemas\n * could be added at the given property (e.g. item-index), thus an array of options is returned. In all other cases\n * a list with a single item will be returned\n *\n * @param core        - core to use\n * @param property    - parent schema of following property\n * @param [schema]    - parent schema of following property\n * @return\n */\nexport default function getChildSchemaSelection(\n    core: Draft,\n    property: string | number,\n    schema: JSONSchema = core.rootSchema\n): JSONSchema[] | JSONError {\n    const result = core.step(property, schema, {}, \"#\");\n\n    if (isJSONError(result)) {\n        if (result.code === \"one-of-error\") {\n            return result.data.oneOf.map((item: JSONSchema) => core.resolveRef(item));\n        }\n        return result;\n    }\n\n    return [result];\n}\n","import getTypeOf from \"./getTypeOf\";\nimport createSchemaOf from \"./createSchemaOf\";\nimport errors from \"./validation/errors\";\nimport merge from \"./utils/merge\";\nimport { JSONSchema, JSONPointer, JSONError, isJSONError } from \"./types\";\nimport { Draft as Core } from \"./draft\";\n\nconst stepType = {\n    array: (\n        core: Core,\n        key: string,\n        schema: JSONSchema,\n        data: any,\n        pointer: JSONPointer\n    ): JSONSchema | JSONError => {\n        const itemsType = getTypeOf(schema.items);\n\n        if (itemsType === \"object\") {\n            // oneOf\n            if (Array.isArray(schema.items.oneOf)) {\n                return core.resolveOneOf(data[key], schema.items, pointer);\n            }\n\n            // anyOf\n            if (Array.isArray(schema.items.anyOf)) {\n                // schema of current object\n                return core.resolveAnyOf(data[key], schema.items, pointer);\n            }\n\n            // allOf\n            if (Array.isArray(schema.items.allOf)) {\n                return core.resolveAllOf(data[key], schema.items, pointer);\n            }\n\n            // spec: ignore additionalItems, when items is schema-object\n            return core.resolveRef(schema.items);\n        }\n\n        if (itemsType === \"array\") {\n            // @draft >= 7 bool schema, items:[true, false]\n            if (schema.items[key] === true) {\n                return createSchemaOf(data[key]);\n            }\n            // @draft >= 7 bool schema, items:[true, false]\n            if (schema.items[key] === false) {\n                return errors.invalidDataError({\n                    key,\n                    value: data[key],\n                    pointer\n                });\n            }\n\n            if (schema.items[key]) {\n                return core.resolveRef(schema.items[key]);\n            }\n\n            if (schema.additionalItems === false) {\n                return errors.additionalItemsError({\n                    key,\n                    value: data[key],\n                    pointer\n                });\n            }\n\n            if (schema.additionalItems === true || schema.additionalItems === undefined) {\n                return createSchemaOf(data[key]);\n            }\n\n            if (getTypeOf(schema.additionalItems) === \"object\") {\n                return schema.additionalItems;\n            }\n\n            throw new Error(\n                `Invalid schema ${JSON.stringify(schema, null, 4)} for ${JSON.stringify(\n                    data,\n                    null,\n                    4\n                )}`\n            );\n        }\n\n        if (schema.additionalItems !== false && data[key]) {\n            // @todo reevaluate: incomplete schema is created here\n            // @todo support additionalItems: {schema}\n            return createSchemaOf(data[key]);\n        }\n\n        return new Error(`Invalid array schema for ${key} at ${pointer}`) as JSONError;\n    },\n\n    object: (\n        core: Core,\n        key: string,\n        schema: JSONSchema,\n        data: any,\n        pointer: JSONPointer\n    ): JSONSchema | JSONError => {\n        if (Array.isArray(schema.oneOf)) {\n            // update current schema\n            const oneOfSchema = core.resolveOneOf(data, schema, pointer);\n            // resolveOneOf does currently not apply merge with base schema\n            schema = merge(schema, oneOfSchema);\n            if (isJSONError(schema)) {\n                return schema;\n            }\n        }\n\n        if (Array.isArray(schema.anyOf)) {\n            // update current schema\n            schema = core.resolveAnyOf(data, schema, pointer);\n            if (isJSONError(schema)) {\n                return schema;\n            }\n        }\n\n        if (Array.isArray(schema.allOf)) {\n            // update current schema\n            schema = core.resolveAllOf(data, schema, pointer);\n            if (isJSONError(schema)) {\n                return schema;\n            }\n        }\n\n        let targetSchema;\n\n        // step into object-properties\n        if (schema.properties && schema.properties[key] !== undefined) {\n            // @todo patternProperties also validate properties\n\n            targetSchema = core.resolveRef(schema.properties[key]);\n            if (isJSONError(targetSchema)) {\n                return targetSchema;\n            }\n\n            // check if there is a oneOf selection, which must be resolved\n            if (targetSchema && Array.isArray(targetSchema.oneOf)) {\n                // @special case: this is a mix of a schema and optional definitions\n                // we resolve the schema here and add the original schema to `oneOfSchema`\n                let resolvedSchema = core.resolveOneOf(\n                    data[key],\n                    targetSchema,\n                    `${pointer}/${key}`\n                );\n\n                const oneOfIndex = targetSchema.oneOf.findIndex((s) => s === resolvedSchema);\n\n                resolvedSchema.variableSchema = true;\n                resolvedSchema.oneOfIndex = oneOfIndex;\n                resolvedSchema.oneOfSchema = targetSchema;\n                return resolvedSchema;\n            }\n\n            // resolved schema or error\n            if (targetSchema) {\n                return targetSchema;\n            }\n        }\n\n        // @draft <= 07\n        const { dependencies } = schema;\n        if (getTypeOf(dependencies) === \"object\") {\n            const dependentProperties = Object.keys(dependencies).filter(\n                (propertyName) =>\n                    // data[propertyName] !== undefined &&\n                    getTypeOf(dependencies[propertyName]) === \"object\"\n            );\n\n            for (let i = 0, l = dependentProperties.length; i < l; i += 1) {\n                const dependentProperty = dependentProperties[i];\n                const schema = step(\n                    core,\n                    key,\n                    dependencies[dependentProperty],\n                    data,\n                    `${pointer}/${dependentProperty}`\n                );\n                if (!isJSONError(schema)) {\n                    return schema;\n                }\n            }\n        }\n\n        // @draft >= 07\n        if (schema.if && (schema.then || schema.else)) {\n            // console.log(\"test if-then-else\");\n            const isValid = core.isValid(data, schema.if);\n            if (isValid && schema.then) {\n                const resolvedThen = step(core, key, schema.then, data, pointer);\n                if (typeof resolvedThen.type === \"string\" && resolvedThen.type !== \"error\") {\n                    return resolvedThen;\n                }\n            }\n            if (!isValid && schema.else) {\n                const resolvedElse = step(core, key, schema.else, data, pointer);\n                if (typeof resolvedElse.type === \"string\" && resolvedElse.type !== \"error\") {\n                    return resolvedElse;\n                }\n            }\n        }\n\n        // find matching property key\n        if (getTypeOf(schema.patternProperties) === \"object\") {\n            let regex;\n            const patterns = Object.keys(schema.patternProperties);\n            for (let i = 0, l = patterns.length; i < l; i += 1) {\n                regex = new RegExp(patterns[i]);\n                if (regex.test(key)) {\n                    return schema.patternProperties[patterns[i]];\n                }\n            }\n        }\n\n        if (getTypeOf(schema.additionalProperties) === \"object\") {\n            return schema.additionalProperties;\n        }\n\n        if (schema.additionalProperties === true) {\n            return createSchemaOf(data[key]);\n        }\n\n        return errors.unknownPropertyError({\n            property: key,\n            value: data,\n            // pointer: `${pointer}/${key}`,\n            pointer: `${pointer}`\n        });\n    }\n};\n\n/**\n * Returns the json-schema of the given object property or array item.\n * e.g. it steps by one key into the data\n *\n *  This helper determines the location of the property within the schema (additional properties, oneOf, ...) and\n *  returns the correct schema.\n *\n * @param  core      - validator\n * @param  key       - property-name or array-index\n * @param  schema    - json schema of current data\n * @param  data      - parent of key\n * @param  [pointer] - pointer to schema and data (parent of key)\n * @return Schema or Error if failed resolving key\n */\nexport default function step(\n    core: Core,\n    key: string | number,\n    schema: JSONSchema,\n    data?: any,\n    pointer: JSONPointer = \"#\"\n): JSONSchema | JSONError {\n    // @draft >= 4 ?\n    if (Array.isArray(schema.type)) {\n        const dataType = getTypeOf(data);\n        if (schema.type.includes(dataType)) {\n            // @ts-ignore\n            return stepType[dataType](core, `${key}`, schema, data, pointer);\n        }\n        return core.errors.typeError({\n            value: data,\n            pointer,\n            expected: schema.type,\n            received: dataType\n        });\n    }\n\n    const expectedType = schema.type || getTypeOf(data);\n    // @ts-ignore\n    const stepFunction = stepType[expectedType];\n    if (stepFunction) {\n        return stepFunction(core, `${key}`, schema, data, pointer);\n    }\n    return new Error(`Unsupported schema type ${schema.type} for key ${key}`) as JSONError;\n}\n","import { JSONTypeValidator } from \"../../types\";\n\n/**\n * @todo: type is also a keyword, as is properties, items, etc\n *\n * An instance has one of six primitive types (http://json-schema.org/latest/json-schema-core.html#rfc.section.4.2)\n * or seven in case of ajv https://github.com/epoberezkin/ajv/blob/master/KEYWORDS.md#type\n * 1 null, 2 boolean, 3 object, 4 array, 5 number, 6 string (7 integer)\n */\nconst validationType: Record<string, JSONTypeValidator> = {\n    array: (core, schema, value, pointer) =>\n        core.typeKeywords.array\n            .filter((key) => schema && schema[key] != null)\n            .map((key) => core.validateKeyword[key](core, schema, value, pointer)),\n\n    object: (core, schema, value, pointer) =>\n        core.typeKeywords.object\n            .filter((key) => schema && schema[key] != null)\n            .map((key) => core.validateKeyword[key](core, schema, value, pointer)),\n\n    string: (core, schema, value, pointer) =>\n        core.typeKeywords.string\n            .filter((key) => schema && schema[key] != null)\n            .map((key) => core.validateKeyword[key](core, schema, value, pointer)),\n\n    integer: (core, schema, value, pointer) =>\n        core.typeKeywords.number\n            .filter((key) => schema && schema[key] != null)\n            .map((key) => core.validateKeyword[key](core, schema, value, pointer)),\n\n    number: (core, schema, value, pointer) =>\n        core.typeKeywords.number\n            .filter((key) => schema && schema[key] != null)\n            .map((key) => core.validateKeyword[key](core, schema, value, pointer)),\n\n    boolean: (core, schema, value, pointer) =>\n        core.typeKeywords.boolean\n            .filter((key) => schema && schema[key] != null)\n            .map((key) => core.validateKeyword[key](core, schema, value, pointer)),\n\n    null: (core, schema, value, pointer) =>\n        core.typeKeywords.null\n            .filter((key) => schema && schema[key] != null)\n            .map((key) => core.validateKeyword[key](core, schema, value, pointer))\n};\n\nexport default validationType;\n","import getTypeOf, { JSType } from \"./getTypeOf\";\nimport { errorOrPromise } from \"./utils/filter\";\nimport flattenArray from \"./utils/flattenArray\";\nimport { JSONSchema, JSONPointer, JSONError, isJSONError } from \"./types\";\nimport { Draft as Core } from \"./draft\";\nimport equal from \"fast-deep-equal\";\n\nfunction getJsonSchemaType(value: unknown, expectedType: string | string[]): JSType | \"integer\" {\n    const jsType = getTypeOf(value);\n    if (\n        jsType === \"number\" &&\n        (expectedType === \"integer\" ||\n            (Array.isArray(expectedType) && expectedType.includes(\"integer\")))\n    ) {\n        return Number.isInteger(value) || isNaN(value as any) ? \"integer\" : \"number\";\n    }\n    return jsType;\n}\n\n/**\n * Validate data by a json schema\n *\n * @param core - validator\n * @param value - value to validate\n * @param [schema] - json schema, defaults to rootSchema\n * @param [pointer] - json pointer pointing to value (used for error-messages only)\n * @return list of errors or empty\n */\nexport default function validate(\n    core: Core,\n    value: unknown,\n    schema: JSONSchema = core.rootSchema,\n    pointer: JSONPointer = \"#\"\n): Array<JSONError> {\n    schema = core.resolveRef(schema);\n\n    // @draft >= 07\n    if (getTypeOf(schema) === \"boolean\") {\n        if (schema) {\n            return [];\n        }\n        return [core.errors.invalidDataError({ value, pointer })];\n    }\n\n    if (isJSONError(schema)) {\n        return [schema as JSONError];\n    }\n\n    // @draft >= 6 const\n    if (schema.const !== undefined) {\n        if (equal(schema.const, value)) {\n            return [];\n        }\n        return [core.errors.constError({ value, expected: schema.const, pointer })];\n    }\n\n    const receivedType = getJsonSchemaType(value, schema.type);\n    const expectedType = schema.type || receivedType;\n\n    if (\n        receivedType !== expectedType &&\n        (!Array.isArray(expectedType) || !expectedType.includes(receivedType))\n    ) {\n        return [\n            core.errors.typeError({\n                received: receivedType,\n                expected: expectedType,\n                value,\n                pointer\n            })\n        ];\n    }\n\n    if (core.validateType[receivedType] == null) {\n        return [core.errors.invalidTypeError({ receivedType, pointer })];\n    }\n\n    const errors = flattenArray(core.validateType[receivedType](core, schema, value, pointer));\n    // also promises may be passed along (validateAsync)\n    // @ts-ignore\n    return errors.filter(errorOrPromise);\n}\n","import addRemoteSchema from \"../addRemoteSchema\";\nimport compileSchema from \"../draft06/compile\";\nimport { each } from \"../each\";\nimport { eachSchema } from \"../eachSchema\";\nimport ERRORS from \"../validation/errors\";\nimport FORMATS from \"../validation/format\";\nimport getSchema from \"../getSchema\";\nimport getTemplate from \"../getTemplate\";\nimport isValid from \"../isValid\";\nimport KEYWORDS from \"../draft06/validation/keyword\";\nimport merge from \"../utils/merge\";\nimport resolveAllOf from \"../resolveAllOf\";\nimport resolveAnyOf from \"../resolveAnyOf\";\nimport resolveOneOf from \"../resolveOneOf.strict\";\nimport resolveRef from \"../resolveRef.strict\";\nimport createSchemaOf from \"../createSchemaOf\";\nimport getChildSchemaSelection from \"../getChildSchemaSelection\";\nimport step from \"../step\";\nimport TYPES from \"../draft06/validation/type\";\nimport validate from \"../validate\";\nimport { DraftConfig, Draft } from \"../draft\";\nimport { JSONSchema } from \"../types\";\n\nconst draft07Config: DraftConfig = {\n    typeKeywords: {\n        array: [\n            \"allOf\",\n            \"anyOf\",\n            \"contains\",\n            \"enum\",\n            \"if\",\n            \"items\",\n            \"maxItems\",\n            \"minItems\",\n            \"not\",\n            \"oneOf\",\n            \"uniqueItems\"\n        ],\n        boolean: [\"allOf\", \"anyOf\", \"enum\", \"not\", \"oneOf\"],\n        object: [\n            \"additionalProperties\",\n            \"allOf\",\n            \"anyOf\",\n            \"dependencies\",\n            \"enum\",\n            \"format\",\n            \"if\",\n            \"maxProperties\",\n            \"minProperties\",\n            \"not\",\n            \"oneOf\",\n            \"patternProperties\",\n            \"properties\",\n            \"propertyNames\",\n            \"required\"\n        ],\n        string: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"format\",\n            \"if\",\n            \"maxLength\",\n            \"minLength\",\n            \"not\",\n            \"oneOf\",\n            \"pattern\"\n        ],\n        number: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"exclusiveMaximum\",\n            \"exclusiveMinimum\",\n            \"format\",\n            \"if\",\n            \"maximum\",\n            \"minimum\",\n            \"multipleOf\",\n            \"not\",\n            \"oneOf\"\n        ],\n        null: [\"allOf\", \"anyOf\", \"enum\", \"format\", \"not\", \"oneOf\"]\n    },\n    validateKeyword: KEYWORDS,\n    validateType: TYPES,\n    validateFormat: FORMATS,\n    errors: ERRORS,\n\n    addRemoteSchema,\n    compileSchema,\n    createSchemaOf,\n    each,\n    eachSchema,\n    getChildSchemaSelection,\n    getSchema,\n    getTemplate,\n    isValid,\n    resolveAllOf,\n    resolveAnyOf,\n    resolveOneOf,\n    resolveRef,\n    step,\n    validate\n};\n\nclass Draft07 extends Draft {\n    constructor(schema?: JSONSchema, config: Partial<DraftConfig> = {}) {\n        super(merge(draft07Config, config), schema);\n    }\n}\n\nexport { Draft07, draft07Config };\n","import merge from \"../utils/merge\";\nimport resolveOneOf from \"../resolveOneOf.fuzzy\";\nimport resolveRef from \"../resolveRef.merge\";\nimport { Draft, DraftConfig } from \"../draft\";\nimport { draft07Config } from \"../draft07\";\nimport { JSONSchema } from \"../types\";\n\nconst draftJsonEditorConfig: DraftConfig = {\n    ...draft07Config,\n    resolveOneOf,\n    resolveRef\n};\n\nclass JsonEditor extends Draft {\n    constructor(schema?: JSONSchema, config: Partial<DraftConfig> = {}) {\n        super(merge(draftJsonEditorConfig, config), schema);\n    }\n}\n\nexport { JsonEditor, draftJsonEditorConfig };\n","import getSchema from \"./getSchema\";\nimport { JsonEditor as Core } from \"./jsoneditor\";\nimport gp from \"@sagold/json-pointer\";\nimport copy from \"./utils/copy\";\nimport { JSONSchema, JSONPointer } from \"./types\";\n\nexport default class SchemaService {\n    core: Core;\n    schema: JSONSchema;\n    data: unknown;\n    cache: Record<string, JSONSchema>;\n\n    constructor(schema: JSONSchema, data: unknown) {\n        this.core = new Core(schema);\n        this.schema = schema;\n        this.data = data;\n        this.cache = {};\n    }\n\n    updateData(data: unknown) {\n        this.data = data;\n        this.cache = {};\n    }\n\n    updateSchema(schema: JSONSchema) {\n        this.schema = schema;\n        this.core.setSchema(schema);\n        this.cache = {};\n    }\n\n    get(pointer: JSONPointer, data: unknown): JSONSchema {\n        if (data) {\n            // possibly separate entry point\n            const schema = getSchema(this.core, pointer, data, this.schema);\n            return copy(schema);\n        }\n\n        if (pointer === \"#\") {\n            // root\n            return this.schema;\n        }\n\n        if (this.cache[pointer]) {\n            // return cached result\n            return this.cache[pointer];\n        }\n\n        const parentPointer = gp.join(pointer, \"..\");\n        let parentSchema = this.cache[parentPointer];\n        if (parentSchema == null) {\n            // store parent (major performance improvement if its within oneof)\n            parentSchema = getSchema(this.core, parentPointer, this.data, this.schema);\n            if (parentSchema.variableSchema !== true) {\n                this.cache[parentPointer] = copy(parentSchema);\n            }\n        }\n\n        // step from parent to child\n        const key = gp.split(pointer).pop();\n        let schema = getSchema(\n            this.core,\n            key,\n            gp.get(this.data, parentPointer),\n            this.cache[parentPointer]\n        );\n        schema = copy(schema);\n        if (schema.variableSchema !== true) {\n            this.cache[pointer] = schema;\n        }\n        return schema;\n    }\n}\n","import { errorsOnly } from \"./utils/filter\";\nimport flattenArray from \"./utils/flattenArray\";\nimport { JSONSchema, JSONPointer, JSONError, isJSONError } from \"./types\";\nimport { Draft as Core } from \"./draft\";\n\nfunction createErrorNotification(onError: OnError) {\n    return function notifyError(error: JSONError | JSONError[]) {\n        if (Array.isArray(error)) {\n            error = flattenArray(error);\n            error.forEach(notifyError);\n            return error;\n        }\n        if (isJSONError(error)) {\n            onError(error);\n        }\n        return error;\n    };\n}\n\nexport interface OnError {\n    (error: JSONError): void;\n}\n\nexport type Options = {\n    schema?: JSONSchema;\n    pointer?: JSONPointer;\n    onError?: OnError;\n};\n\n/**\n * @async\n * Validate data by a json schema\n *\n * @param core - validator\n * @param value - value to validate\n * @param options\n * @param options.schema - json schema to use, defaults to core.rootSchema\n * @param options.pointer - json pointer pointing to current value. Used in error reports\n * @param options.onError   - will be called for each error as soon as it is resolved\n * @return list of errors or empty\n */\nexport default function validateAsync(\n    core: Core,\n    value: any,\n    options?: Options\n): Promise<Array<JSONError>> {\n    const { schema, pointer, onError } = { schema: core.rootSchema, pointer: \"#\", ...options };\n\n    let errors: Array<JSONError> = core.validate(value, schema, pointer);\n    if (onError) {\n        errors = flattenArray(errors);\n        const notifyError = createErrorNotification(onError);\n        for (let i = 0; i < errors.length; i += 1) {\n            if (errors[i] instanceof Promise) {\n                errors[i].then(notifyError);\n            } else if (isJSONError(errors[i])) {\n                onError(errors[i]);\n            }\n        }\n    }\n\n    return Promise.all(errors)\n        .then(flattenArray)\n        .then((resolvedErrors) => resolvedErrors.filter(errorsOnly))\n        .catch((e) => {\n            console.log(\"Failed resolving promises\", e.message);\n            console.log(e.stack);\n            throw e;\n        });\n}\n","/* eslint max-statements-per-line: [\"error\", { \"max\": 2 }] */\nimport { eachSchema } from \"../eachSchema\";\nimport { Draft } from \"../draft\";\nimport joinScope from \"./joinScope\";\nimport getRef from \"./getRef\";\nimport { JSONSchema } from \"../types\";\nimport { Context } from \"./types\";\nimport { get } from \"@sagold/json-pointer\";\n\nconst COMPILED = \"__compiled\";\nconst COMPILED_REF = \"__ref\";\nconst GET_REF = \"getRef\";\nconst GET_ROOT = \"getRoot\";\nconst suffixes = /(#|\\/)+$/g;\n\n/**\n * compiles the input root schema for `$ref` resolution and returns it again\n * @attention this modifies input schema but maintains data-structure and thus returns\n * the same object with JSON.stringify\n *\n * for a compiled json-schema you can call getRef on any contained schema (location of type).\n * this resolves a $ref target to a valid schema (for a valid $ref)\n *\n * @param draft\n * @param schemaToCompile - json-schema to compile\n * @param [rootSchema] - compiled root json-schema to use for definitions resolution\n * @param [force] = false - force compile json-schema\n * @return compiled input json-schema\n */\nexport default function compileSchema(\n    draft: Draft,\n    schemaToCompile: JSONSchema,\n    rootSchema: JSONSchema = schemaToCompile,\n    force = false\n): JSONSchema {\n    if (!schemaToCompile || schemaToCompile[COMPILED] !== undefined) {\n        return schemaToCompile;\n    }\n\n    const context: Context = { ids: {}, remotes: draft.remotes };\n    const rootSchemaAsString = JSON.stringify(schemaToCompile);\n    const compiledSchema: JSONSchema = JSON.parse(rootSchemaAsString);\n\n    // flag this schema as compiled\n    Object.defineProperty(compiledSchema, COMPILED, { enumerable: false, value: true });\n    // add getRef-helper to this object\n    Object.defineProperty(compiledSchema, GET_REF, {\n        enumerable: false,\n        value: getRef.bind(null, context, compiledSchema)\n    });\n\n    // bail early, when no $refs are defined\n    if (force === false && rootSchemaAsString.includes(\"$ref\") === false) {\n        return compiledSchema;\n    }\n\n    // compile this schema under rootSchema, making definitions available to $ref-resolution\n    if (schemaToCompile !== rootSchema) {\n        Object.defineProperty(compiledSchema, \"definitions\", {\n            enumerable: false,\n            value: Object.assign(\n                {},\n                rootSchema.definitions,\n                rootSchema.$defs,\n                schemaToCompile.definitions,\n                schemaToCompile.$defs\n            )\n        });\n    }\n\n    const scopes: Record<string, string> = {};\n    const getRoot = () => compiledSchema;\n\n    eachSchema(compiledSchema, (schema, pointer) => {\n        if (schema.id) {\n            // if this is a schema being merged on root object, we cannot override\n            // parents locations, but must reuse it\n            if (schema.id.startsWith(\"http\") && /(allOf|anyOf|oneOf)\\/\\d+$/.test(pointer)) {\n                const parentPointer = pointer.replace(/\\/(allOf|anyOf|oneOf)\\/\\d+$/, \"\");\n                const parentSchema = get(compiledSchema, parentPointer);\n                schema.id = parentSchema.id ?? schema.id;\n            }\n            context.ids[schema.id.replace(suffixes, \"\")] = pointer;\n        }\n\n        // build up scopes and add them to $ref-resolution map\n        pointer = `#${pointer}`.replace(/##+/, \"#\");\n        const previousPointer = pointer.replace(/\\/[^/]+$/, \"\");\n        const parentPointer = pointer.replace(/\\/[^/]+\\/[^/]+$/, \"\");\n        const previousScope = scopes[previousPointer] || scopes[parentPointer];\n        const scope = joinScope(previousScope, schema.id);\n        scopes[pointer] = scope;\n        if (context.ids[scope] == null) {\n            context.ids[scope] = pointer;\n        }\n\n        if (schema.$ref && !schema[COMPILED_REF]) {\n            Object.defineProperty(schema, COMPILED_REF, {\n                enumerable: false,\n                value: joinScope(scope, schema.$ref)\n            });\n            // @todo currently not used:\n            Object.defineProperty(schema, GET_ROOT, { enumerable: false, value: getRoot });\n            // console.log(\"compiled ref\", scope, schema.$ref, \"=>\", joinScope(scope, schema.$ref));\n        }\n    });\n\n    // console.log(JSON.stringify(context.ids, null, 2));\n    return compiledSchema;\n}\n","import compile from \"./compile\";\nexport default compile;\n","import addRemoteSchema from \"../addRemoteSchema\";\nimport compileSchema from \"../compileSchema\";\nimport { each } from \"../each\";\nimport { eachSchema } from \"../eachSchema\";\nimport ERRORS from \"../validation/errors\";\nimport FORMATS from \"../validation/format\";\nimport getSchema from \"../getSchema\";\nimport getTemplate from \"../getTemplate\";\nimport isValid from \"../isValid\";\nimport KEYWORDS from \"../validation/keyword\";\nimport merge from \"../utils/merge\";\nimport resolveAllOf from \"../resolveAllOf\";\nimport resolveAnyOf from \"../resolveAnyOf\";\nimport resolveOneOf from \"../resolveOneOf.strict\";\nimport resolveRef from \"../resolveRef.strict\";\nimport step from \"../step\";\nimport createSchemaOf from \"../createSchemaOf\";\nimport getChildSchemaSelection from \"../getChildSchemaSelection\";\nimport TYPES from \"../validation/type\";\nimport validate from \"../validate\";\nimport { DraftConfig, Draft } from \"../draft\";\nimport { JSONSchema } from \"../types\";\n\nconst draft04Config: DraftConfig = {\n    typeKeywords: {\n        array: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"items\",\n            \"maxItems\",\n            \"minItems\",\n            \"not\",\n            \"oneOf\",\n            \"uniqueItems\"\n        ],\n        boolean: [\"enum\", \"not\", \"allOf\", \"anyOf\", \"oneOf\"],\n        object: [\n            \"additionalProperties\",\n            \"dependencies\",\n            \"enum\",\n            \"format\",\n            \"minProperties\",\n            \"maxProperties\",\n            \"patternProperties\",\n            \"properties\",\n            \"required\",\n            \"not\",\n            \"oneOf\",\n            \"allOf\",\n            \"anyOf\"\n        ],\n        string: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"format\",\n            \"maxLength\",\n            \"minLength\",\n            \"not\",\n            \"oneOf\",\n            \"pattern\"\n        ],\n        number: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"format\",\n            \"maximum\",\n            \"minimum\",\n            \"multipleOf\",\n            \"not\",\n            \"oneOf\"\n        ],\n        null: [\"allOf\", \"anyOf\", \"enum\", \"format\", \"not\", \"oneOf\"]\n    },\n    validateKeyword: KEYWORDS,\n    validateType: TYPES,\n    validateFormat: FORMATS,\n    errors: ERRORS,\n\n    addRemoteSchema,\n    compileSchema,\n    createSchemaOf,\n    each,\n    eachSchema,\n    getChildSchemaSelection,\n    getSchema,\n    getTemplate,\n    isValid,\n    resolveAllOf,\n    resolveAnyOf,\n    resolveOneOf,\n    resolveRef,\n    step,\n    validate\n};\n\nclass Draft04 extends Draft {\n    constructor(schema?: JSONSchema, config: Partial<DraftConfig> = {}) {\n        super(merge(draft04Config, config), schema);\n    }\n}\n\nexport { Draft04, draft04Config };\n","import { JSONTypeValidator } from \"../types\";\n\n/**\n * @todo: type is also a keyword, as is properties, items, etc\n *\n * An instance has one of six primitive types (http://json-schema.org/latest/json-schema-core.html#rfc.section.4.2)\n * or seven in case of ajv https://github.com/epoberezkin/ajv/blob/master/KEYWORDS.md#type\n * 1 null, 2 boolean, 3 object, 4 array, 5 number, 6 string (7 integer)\n */\nconst typeValidators: Record<string, JSONTypeValidator> = {\n\n    array: (core, schema, value, pointer) =>\n        core.typeKeywords.array\n            .filter(key => schema && schema[key] != null)\n            .map(key => core.validateKeyword[key](core, schema, value, pointer)),\n\n    object: (core, schema, value, pointer) =>\n        core.typeKeywords.object\n            .filter(key => schema && schema[key] != null)\n            .map(key => core.validateKeyword[key](core, schema, value, pointer)),\n\n    string: (core, schema, value, pointer) =>\n        core.typeKeywords.string\n            .filter(key => schema && schema[key] != null)\n            .map(key => core.validateKeyword[key](core, schema, value, pointer)),\n\n    integer: (core, schema, value, pointer) =>\n        core.typeKeywords.number\n            .filter(key => schema && schema[key] != null)\n            .map(key => core.validateKeyword[key](core, schema, value, pointer)),\n\n    number: (core, schema, value, pointer) =>\n        core.typeKeywords.number\n            .filter(key => schema && schema[key] != null)\n            .map(key => core.validateKeyword[key](core, schema, value, pointer)),\n\n    \"boolean\": (core, schema, value, pointer) =>\n        core.typeKeywords.boolean\n            .filter(key => schema && schema[key] != null)\n            .map(key => core.validateKeyword[key](core, schema, value, pointer)),\n\n    \"null\": (core, schema, value, pointer) =>\n        core.typeKeywords.null\n            .filter(key => schema && schema[key] != null)\n            .map(key => core.validateKeyword[key](core, schema, value, pointer))\n};\n\nexport default typeValidators;\n","import addRemoteSchema from \"../addRemoteSchema\";\nimport compileSchema from \"../draft06/compile\";\nimport { each } from \"../each\";\nimport { eachSchema } from \"../eachSchema\";\nimport ERRORS from \"../validation/errors\";\nimport FORMATS from \"../validation/format\";\nimport getSchema from \"../getSchema\";\nimport getTemplate from \"../getTemplate\";\nimport isValid from \"../isValid\";\nimport KEYWORDS from \"../draft06/validation/keyword\";\nimport merge from \"../utils/merge\";\nimport resolveAllOf from \"../resolveAllOf\";\nimport resolveAnyOf from \"../resolveAnyOf\";\nimport resolveOneOf from \"../resolveOneOf.strict\";\nimport resolveRef from \"../resolveRef.strict\";\nimport createSchemaOf from \"../createSchemaOf\";\nimport getChildSchemaSelection from \"../getChildSchemaSelection\";\nimport step from \"../step\";\nimport TYPES from \"../draft06/validation/type\";\nimport validate from \"../validate\";\nimport { DraftConfig, Draft } from \"../draft\";\nimport { JSONSchema } from \"../types\";\n\nconst draft06Config: DraftConfig = {\n    typeKeywords: {\n        array: [\n            \"allOf\",\n            \"anyOf\",\n            \"contains\",\n            \"enum\",\n            \"if\",\n            \"items\",\n            \"maxItems\",\n            \"minItems\",\n            \"not\",\n            \"oneOf\",\n            \"uniqueItems\"\n        ],\n        boolean: [\"allOf\", \"anyOf\", \"enum\", \"not\", \"oneOf\"],\n        object: [\n            \"additionalProperties\",\n            \"allOf\",\n            \"anyOf\",\n            \"dependencies\",\n            \"enum\",\n            \"format\",\n            \"if\",\n            \"maxProperties\",\n            \"minProperties\",\n            \"not\",\n            \"oneOf\",\n            \"patternProperties\",\n            \"properties\",\n            \"propertyNames\",\n            \"required\"\n        ],\n        string: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"format\",\n            \"if\",\n            \"maxLength\",\n            \"minLength\",\n            \"not\",\n            \"oneOf\",\n            \"pattern\"\n        ],\n        number: [\n            \"enum\",\n            \"exclusiveMaximum\",\n            \"exclusiveMinimum\",\n            \"format\",\n            \"maximum\",\n            \"minimum\",\n            \"multipleOf\",\n            \"not\",\n            \"oneOf\",\n            \"allOf\",\n            \"anyOf\",\n            \"if\"\n        ],\n        null: [\"allOf\", \"anyOf\", \"enum\", \"format\", \"not\", \"oneOf\"]\n    },\n    validateKeyword: KEYWORDS,\n    validateType: TYPES,\n    validateFormat: FORMATS,\n    errors: ERRORS,\n\n    addRemoteSchema,\n    compileSchema,\n    createSchemaOf,\n    each,\n    eachSchema,\n    getChildSchemaSelection,\n    getSchema,\n    getTemplate,\n    isValid,\n    resolveAllOf,\n    resolveAnyOf,\n    resolveOneOf,\n    resolveRef,\n    step,\n    validate\n};\n\nclass Draft06 extends Draft {\n    constructor(schema?: JSONSchema, config: Partial<DraftConfig> = {}) {\n        super(merge(draft06Config, config), schema);\n    }\n}\n\nexport { Draft06, draft06Config };\n","import { createError, createCustomError } from \"./lib/utils/createCustomError\";\nimport getTypeOf from \"./lib/getTypeOf\";\nimport resolveOneOf from \"./lib/resolveOneOf.strict\";\nimport resolveAllOf from \"./lib/resolveAllOf\";\nimport resolveOneOfFuzzy from \"./lib/resolveOneOf.fuzzy\";\nimport resolveRef from \"./lib/resolveRef.strict\";\nimport resolveRefMerge from \"./lib/resolveRef.merge\";\nimport SchemaService from \"./lib/SchemaService\";\nimport settings from \"./lib/config/settings\";\nimport strings from \"./lib/config/strings\";\nimport validateAsync from \"./lib/validateAsync\";\nimport render from \"./lib/utils/render\";\nimport { Draft } from \"./lib/draft\";\nimport { Draft04, draft04Config } from \"./lib/draft04\";\nimport { Draft06, draft06Config } from \"./lib/draft06\";\nimport { Draft07, draft07Config } from \"./lib/draft07\";\nimport { JsonEditor, draftJsonEditorConfig } from \"./lib/jsoneditor\";\nimport { isJSONError } from \"./lib/types\";\n\nconst config = { strings };\n\nexport {\n    config,\n    Draft,\n    Draft04, // core implementing draft04 specs\n    draft04Config, // config implementing draft04 specs\n    Draft06, // core implementing draft06 specs\n    draft06Config, // config implementing draft06 specs\n    Draft07, // core implementing draft07 specs\n    draft07Config, // config implementing draft07 specs\n    JsonEditor, // adjusted core of draft04 to better support the json-editor\n    draftJsonEditorConfig, // adjusted config of draft04 to better support the json-editor\n    createError,\n    createCustomError,\n    getTypeOf, // returns the javascript datatype\n    isJSONError,\n    render,\n    resolveAllOf,\n    resolveRef,\n    resolveRefMerge,\n    resolveOneOf,\n    resolveOneOfFuzzy,\n    settings,\n    SchemaService,\n    validateAsync // async validation of data by a schema\n};\n\nimport { DraftConfig } from \"./lib/draft\";\nimport { EachCallback } from \"./lib/each\";\nimport { EachSchemaCallback } from \"./lib/eachSchema\";\nimport { ErrorData, CreateError } from \"./lib/utils/createCustomError\";\nimport { JSONSchema, JSONPointer, JSONError, JSONValidator, JSONTypeValidator } from \"./lib/types\";\nimport { JSType } from \"./lib/getTypeOf\";\n\nexport type {\n    CreateError,\n    DraftConfig,\n    EachCallback,\n    EachSchemaCallback,\n    ErrorData,\n    JSONError,\n    JSONPointer,\n    JSONSchema,\n    JSONTypeValidator,\n    JSONValidator,\n    JSType\n};\n"],"names":["root","factory","exports","module","define","amd","self","this","e","d","t","n","r","o","Object","defineProperty","enumerable","get","prototype","hasOwnProperty","call","Symbol","toStringTag","value","Array","isArray","length","default","x","c","isRoot","join","_","remove","v","removeUndefinedItems","j","set","y","split","s","i","l","u","replace","f","decodeURIComponent","indexOf","p","shift","a","g","test","m","pop","h","match","push","b","A","P","O","encodeURIComponent","arguments","apply","splitLast","isMergeableObject","isNonNullObject","stringValue","toString","$$typeof","REACT_ELEMENT_TYPE","isReactElement","isSpecial","for","cloneUnlessOtherwiseSpecified","options","clone","deepmerge","val","defaultArrayMerge","target","source","concat","map","element","getKeys","keys","getOwnPropertySymbols","filter","symbol","propertyIsEnumerable","getEnumerableOwnPropertySymbols","propertyIsOnObject","object","property","mergeObject","destination","forEach","key","propertyIsUnsafe","customMerge","getMergeFunction","arrayMerge","sourceIsArray","all","array","Error","reduce","prev","next","deepmerge_1","Parser_1","BNF","RULES","name","bnf","fragment","pinned","defaultParser","Parser","debug","preDecorationRE","decorationRE","subExpressionRE","getBNFRule","parser","decoration","exec","decorationText","lonely","rule","findRuleByName","RegExp","isLonelyRule","getBNFBody","rules","getBNFChoice","emit","acumulator","grammarRules","recover","subitems","convertRegex","txt","getSubItems","tmpRules","seq","parentName","anterior","bnfSeq","children","type","total","resta","console","log","restar","text","createRule","newRule","JSON","stringify","token","getRules","ast","getAST","errors","Transform","subParser","constructor","super","debugRulesParser","emitSource","parseRuleName","escapeRegExp","readToken","UPPER_SNAKE_RE","WS_RULE","TokenError_1","expr","result","index","rest","substr","start","end","fullText","parent","str","fixRest","fixPositions","agregateErrors","err","tok","postDecoration","preDecoration","postDecorationText","preDecorationText","out","raw","isOptional","allowRepetition","atLeastOne","lookupPositive","lookupNegative","lookup","isLiteral","parsed","cachedRules","stripRules","re","localRules","indexOnChildren","splice","ignoreMissingRules","neededRules","parsedName","error","option","implicitWs","ruleName","parse","keepUpperRules","TokenError","recursion","printable","realType","targetLex","src","eval","ReferenceError","phases","tmp","tmpTxt","position","allOptional","foundSomething","got","localTarget","foundAtLeastOne","WS","parseRecovery","simplifyWhenOneChildren","recoverableToken","message","inspect","equal","flags","valueOf","is_uri","is_iri","is_http_uri","is_http_iri","is_https_uri","is_https_iri","is_web_uri","is_web_iri","isUri","isHttpUri","isHttpsUri","isWebUri","splitUri","uri","splitted","authority","path","query","scheme","toLowerCase","allowHttps","port","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","id","loaded","__webpack_modules__","getter","__esModule","definition","obj","prop","nmd","paths","AdditionalItemsError","AdditionalPropertiesError","AllOfError","AnyOfError","ConstError","containsAnyError","ContainsArrayError","ContainsError","EnumError","FormatDateError","FormatDateTimeError","FormatEmailError","FormatHostnameError","FormatIPV4Error","FormatIPV4LeadingZeroError","FormatIPV6Error","FormatIPV6LeadingZeroError","FormatJSONPointerError","FormatRegExError","FormatTimeError","FormatURIError","FormatURIReferenceError","FormatURITemplateError","FormatURLError","InvalidDataError","InvalidPropertyNameError","MaximumError","MaxItemsError","MaxLengthError","MaxPropertiesError","MinimumError","MinItemsError","MinItemsOneError","MinLengthError","MinLengthOneError","MinPropertiesError","MissingDependencyError","MissingOneOfPropertyError","MultipleOfError","MultipleOneOfError","NoAdditionalPropertiesError","NotError","OneOfError","OneOfPropertyError","PatternError","PatternPropertiesError","RequiredPropertyError","TypeError","UndefinedValueError","UniqueItemsError","UnknownPropertyError","ValueNotEmptyError","render","template","data","__","keyword","fallback","strings","createError","code","createCustomError","bind","getTypeOf","isJSONError","errorOrPromise","Promise","errorsOnly","flattenArray","list","item","DECLARATOR_ONEOF","GET_TEMPLATE_RECURSION_LIMIT","floatingPointPrecision","propertyBlacklist","settings","resolveOneOf","core","schema","rootSchema","pointer","oneOfProperty","oneOfValue","missingOneOfPropertyError","oneOf","one","resolveRef","oneOfPropertySchema","step","validate","oneOfPropertyError","matches","multipleOneOfError","oneOfError","overwriteMerge","destinationArray","sourceArray","mergeUniqueItems","pos","resolveSchema","draft","schemaToResolve","if","then","else","isValid","resolveAllOf","mergedSchema","copy","allOf","allOfSchema","getTemplate","fuzzyObjectValue","properties","schemaOfItem","fuzzyGreatest","fuzzyValue","$ref","getRoot","getRef","resolveRefMerge","resolvedSchema","assign","__ref","emptyObject","getSchema","frags","_get","Draft","config","remotes","typeKeywords","validateKeyword","validateType","validateFormat","setSchema","__rootSchema","compileSchema","addRemoteSchema","url","createSchemaOf","each","callback","eachSchema","getChildSchemaSelection","opts","resolveAnyOf","propertyRegex","jsonQueryGrammar","rContainer","isContainer","nodeAsRegex","node","cache","mem","entry","includes","reset","expand","any","childEntry","regex","escaped","typecheck","checkedTyped","lookahead","valid","or","expression","cmp","valueString","expressionMatches","runPatternOnce","inputSet","resultingSet","workingSet","runNode","pattern","quantifier","find","iterationCount","Infinity","count","parseInt","isNaN","getIterationCount","func","input","collect","output","skip","returnTypes","ReturnType","queryString","returnType","VALUE","run","POINTER","ALL","MAP","buildPath","cp","getType","isProperty","ignoreTypes","arrayHasIndex","isEscaped","isArrayProp","convertToIndex","removeEscape","addToArray","force","INSERT_ITEMS","arrayIndex","insert","REPLACE_ITEMS","InsertMode","arrayWithoutIndex","nextSet","nextKey","insertArray","keyIsArray","container","create","targetValue","unescapedProp","definitions","anyOf","validationKeywords","keywords","boolean","enum","integer","not","number","null","string","types","getTypeId","ids","getTypeDefs","defs","def","nextTypeDefs","eachDefinition","walk","defId","defschema","schemaPointer","$defs","suffixes","trailingHash","isDomain","trailingFragments","idAndPointer","joinScope","previous","emptyValues","context","$remote","fragments","splitRef","base","COMPILED","COMPILED_REF","schemaToCompile","rootSchemaAsString","compiledSchema","scopes","$id","startsWith","parentPointer","parentSchema","previousPointer","scope","dataType","nextSchema","additionalItemsError","additionalPropertiesError","anyOfError","allOfError","constError","containsError","containsArrayError","enumError","formatURLError","formatURIError","formatURIReferenceError","formatURITemplateError","formatDateError","formatDateTimeError","formatEmailError","formatHostnameError","formatIPV4Error","formatIPV4LeadingZeroError","formatIPV6Error","formatIPV6LeadingZeroError","formatJSONPointerError","formatRegExError","formatTimeError","invalidSchemaError","invalidDataError","invalidTypeError","invalidPropertyNameError","maximumError","maxItemsError","maxLengthError","maxPropertiesError","minimumError","minItemsError","minItemsOneError","minLengthError","minLengthOneError","minPropertiesError","missingDependencyError","multipleOfError","noAdditionalPropertiesError","notError","patternError","patternPropertiesError","requiredPropertyError","typeError","undefinedValueError","uniqueItemsError","unknownPropertyError","valueNotEmptyError","isValidDateTime","isValidIPV4","isValidIPV6","isValidHostname","matchDate","matchTime","DAYS","isValidJSONPointer","isValidRelativeJSONPointer","isValidURIRef","isValidURITemplate","date","year","month","day","Date","email","host","endsWith","every","part","hostname","ipv4","ipv6","time","hour","minute","second","timeZone","defaultOptions","addOptionalProps","removeInvalidData","shouldResolveRef","createTemplateSchema","templateSchema","resolvedAnyOf","merge","isJSONSchema","_schema","const","isEmpty","defaultValue","defaultType","selectType","convertValue","TYPE","getDefault","required","isRequired","dependencies","dependency","additionalData","minItems","items","Math","max","oneOfSchema","itemCount","templateValue","initValue","mi","deepCompareStrict","typeofa","aKeys","bKeys","k","ucs2decode","counter","charCodeAt","extra","FPP","hasProperty","KeywordValidation","additionalProperties","patternProperties","receivedProperties","expectedProperties","patterns","isObject","subSchema","dependencyErrors","missingProperty","valueStr","values","format","itemData","itemSchema","itemErrors","maximum","exclusiveMaximum","maxItems","maxLength","lengthOfString","maxProperties","propertyCount","minLength","minimum","exclusiveMinimum","minProperties","multipleOf","description","patternExample","received","pp","patternSchema","patternFound","valErrors","keyErrors","propertiesRequired","requiredNotEmpty","uniqueItems","itemPointer","duplicatePointer","contains","ifErrors","propertyNames","propertySchema","validationResult","validationError","found","anyOfSchema","stepType","itemsType","additionalItems","targetSchema","oneOfIndex","findIndex","variableSchema","dependentProperties","propertyName","dependentProperty","resolvedThen","resolvedElse","expected","expectedType","stepFunction","receivedType","jsType","Number","isInteger","getJsonSchemaType","draft07Config","Draft07","draftJsonEditorConfig","JsonEditor","SchemaService","updateData","updateSchema","validateAsync","onError","notifyError","createErrorNotification","resolvedErrors","catch","stack","draft04Config","Draft04","draft06Config","Draft06"],"sourceRoot":""}